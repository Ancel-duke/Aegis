"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/alerts/page",{

/***/ "(app-pages-browser)/./src/lib/websocket.ts":
/*!******************************!*\
  !*** ./src/lib/websocket.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WS_EVENTS: () => (/* binding */ WS_EVENTS),\n/* harmony export */   useWebSocket: () => (/* binding */ useWebSocket)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ useWebSocket,WS_EVENTS auto */ \n\nfunction useWebSocket(param) {\n    let { url, onMessage, onOpen, onClose, onError, reconnect = true, reconnectInterval = 5000, maxRetries = 5 } = param;\n    const socket = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const retryCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const reconnectTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[connect]\": ()=>{\n            var _socket_current;\n            if ((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) {\n                return;\n            }\n            setIsConnecting(true);\n            try {\n                // Get JWT token for authentication\n                const getToken = {\n                    \"useWebSocket.useCallback[connect].getToken\": ()=>{\n                        if (false) {}\n                        // Try localStorage first\n                        const localToken = localStorage.getItem('accessToken');\n                        if (localToken) return localToken;\n                        // Try cookie (if not HttpOnly)\n                        const cookieMatch = document.cookie.match(/accessToken=([^;]+)/);\n                        if (cookieMatch) return cookieMatch[1];\n                        return null;\n                    }\n                }[\"useWebSocket.useCallback[connect].getToken\"];\n                const token = getToken();\n                if (!token) {\n                    console.warn('No JWT token available for WebSocket connection');\n                    setIsConnecting(false);\n                    onError === null || onError === void 0 ? void 0 : onError(new Event('no-token'));\n                    return;\n                }\n                // Socket.IO connection options\n                // Extract base URL and namespace from the provided URL\n                // If URL ends with /ws, treat /ws as the namespace\n                const urlObj = new URL(url.replace(/^ws:\\/\\//, 'http://').replace(/^wss:\\/\\//, 'https://'));\n                const baseUrl = \"\".concat(urlObj.protocol, \"//\").concat(urlObj.host);\n                socket.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(baseUrl, {\n                    auth: {\n                        token\n                    },\n                    query: {\n                        token\n                    },\n                    transports: [\n                        'websocket',\n                        'polling'\n                    ],\n                    reconnection: reconnect,\n                    reconnectionDelay: reconnectInterval,\n                    reconnectionAttempts: maxRetries,\n                    autoConnect: true\n                });\n                socket.current.on('connect', {\n                    \"useWebSocket.useCallback[connect]\": ()=>{\n                        setIsConnected(true);\n                        setIsConnecting(false);\n                        retryCount.current = 0;\n                        onOpen === null || onOpen === void 0 ? void 0 : onOpen();\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('disconnect', {\n                    \"useWebSocket.useCallback[connect]\": (reason)=>{\n                        setIsConnected(false);\n                        setIsConnecting(false);\n                        onClose === null || onClose === void 0 ? void 0 : onClose();\n                        // If disconnect was not intentional, attempt manual reconnection\n                        if (reconnect && reason !== 'io client disconnect' && retryCount.current < maxRetries) {\n                            retryCount.current += 1;\n                            reconnectTimeout.current = setTimeout({\n                                \"useWebSocket.useCallback[connect]\": ()=>{\n                                    connect();\n                                }\n                            }[\"useWebSocket.useCallback[connect]\"], reconnectInterval);\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('connect_error', {\n                    \"useWebSocket.useCallback[connect]\": (error)=>{\n                        setIsConnecting(false);\n                        console.error('WebSocket connection error:', error);\n                        onError === null || onError === void 0 ? void 0 : onError(error);\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for alert events (backend emits 'alert' with { event: 'alert', data: {...} })\n                socket.current.on('alert', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (onMessage && data.data) {\n                            onMessage({\n                                type: 'alert',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for anomaly events\n                socket.current.on('anomaly', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (onMessage && data.data) {\n                            onMessage({\n                                type: 'anomaly',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Generic message handler for other event types\n                socket.current.onAny({\n                    \"useWebSocket.useCallback[connect]\": function(eventName) {\n                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                            args[_key - 1] = arguments[_key];\n                        }\n                        if (onMessage && args.length > 0) {\n                            const payload = args[0];\n                            if (typeof payload === 'object' && payload !== null) {\n                                onMessage({\n                                    type: eventName,\n                                    payload: 'data' in payload ? payload.data : payload\n                                });\n                            }\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n            } catch (error) {\n                setIsConnecting(false);\n                console.error('Failed to connect WebSocket:', error);\n                onError === null || onError === void 0 ? void 0 : onError(error);\n            }\n        }\n    }[\"useWebSocket.useCallback[connect]\"], [\n        url,\n        onMessage,\n        onOpen,\n        onClose,\n        onError,\n        reconnect,\n        reconnectInterval,\n        maxRetries\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[disconnect]\": ()=>{\n            if (reconnectTimeout.current) {\n                clearTimeout(reconnectTimeout.current);\n            }\n            if (socket.current) {\n                socket.current.disconnect();\n                socket.current = null;\n            }\n            setIsConnected(false);\n        }\n    }[\"useWebSocket.useCallback[disconnect]\"], []);\n    const send = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[send]\": (data)=>{\n            var _socket_current;\n            if ((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) {\n                socket.current.emit(data.type, data.payload);\n            } else {\n                console.warn('WebSocket is not connected');\n            }\n        }\n    }[\"useWebSocket.useCallback[send]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWebSocket.useEffect\": ()=>{\n            connect();\n            return ({\n                \"useWebSocket.useEffect\": ()=>{\n                    disconnect();\n                }\n            })[\"useWebSocket.useEffect\"];\n        }\n    }[\"useWebSocket.useEffect\"], [\n        connect,\n        disconnect\n    ]);\n    return {\n        isConnected,\n        isConnecting,\n        connect,\n        disconnect,\n        send\n    };\n}\n// WebSocket event types\nconst WS_EVENTS = {\n    // Alerts\n    ALERT_CREATED: 'alert:created',\n    ALERT_UPDATED: 'alert:updated',\n    ALERT_RESOLVED: 'alert:resolved',\n    // Metrics\n    METRICS_UPDATE: 'metrics:update',\n    // Logs\n    LOG_ENTRY: 'log:entry',\n    // AI\n    ANOMALY_DETECTED: 'ai:anomaly_detected',\n    PREDICTION_UPDATE: 'ai:prediction_update',\n    // Executor\n    ACTION_STARTED: 'executor:action_started',\n    ACTION_COMPLETED: 'executor:action_completed',\n    ACTION_FAILED: 'executor:action_failed'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvd2Vic29ja2V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OzRFQUVpRTtBQUNuQjtBQWtCdkMsU0FBU0ssYUFBYSxLQVNQO1FBVE8sRUFDM0JDLEdBQUcsRUFDSEMsU0FBUyxFQUNUQyxNQUFNLEVBQ05DLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxZQUFZLElBQUksRUFDaEJDLG9CQUFvQixJQUFJLEVBQ3hCQyxhQUFhLENBQUMsRUFDTSxHQVRPO0lBVTNCLE1BQU1DLFNBQVNiLDZDQUFNQSxDQUFnQjtJQUNyQyxNQUFNYyxhQUFhZCw2Q0FBTUEsQ0FBQztJQUMxQixNQUFNZSxtQkFBbUJmLDZDQUFNQSxDQUF3QjtJQUN2RCxNQUFNLENBQUNnQixhQUFhQyxlQUFlLEdBQUdmLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2dCLGNBQWNDLGdCQUFnQixHQUFHakIsK0NBQVFBLENBQUM7SUFFakQsTUFBTWtCLFVBQVVuQixrREFBV0E7NkNBQUM7Z0JBQ3RCWTtZQUFKLEtBQUlBLGtCQUFBQSxPQUFPUSxPQUFPLGNBQWRSLHNDQUFBQSxnQkFBZ0JTLFNBQVMsRUFBRTtnQkFDN0I7WUFDRjtZQUVBSCxnQkFBZ0I7WUFFaEIsSUFBSTtnQkFDRixtQ0FBbUM7Z0JBQ25DLE1BQU1JO2tFQUFXO3dCQUNmLElBQUksS0FBNkIsRUFBRSxFQUFZO3dCQUMvQyx5QkFBeUI7d0JBQ3pCLE1BQU1DLGFBQWFDLGFBQWFDLE9BQU8sQ0FBQzt3QkFDeEMsSUFBSUYsWUFBWSxPQUFPQTt3QkFDdkIsK0JBQStCO3dCQUMvQixNQUFNRyxjQUFjQyxTQUFTQyxNQUFNLENBQUNDLEtBQUssQ0FBQzt3QkFDMUMsSUFBSUgsYUFBYSxPQUFPQSxXQUFXLENBQUMsRUFBRTt3QkFDdEMsT0FBTztvQkFDVDs7Z0JBRUEsTUFBTUksUUFBUVI7Z0JBRWQsSUFBSSxDQUFDUSxPQUFPO29CQUNWQyxRQUFRQyxJQUFJLENBQUM7b0JBQ2JkLGdCQUFnQjtvQkFDaEJWLG9CQUFBQSw4QkFBQUEsUUFBVSxJQUFJeUIsTUFBTTtvQkFDcEI7Z0JBQ0Y7Z0JBRUEsK0JBQStCO2dCQUMvQix1REFBdUQ7Z0JBQ3ZELG1EQUFtRDtnQkFDbkQsTUFBTUMsU0FBUyxJQUFJQyxJQUFJL0IsSUFBSWdDLE9BQU8sQ0FBQyxZQUFZLFdBQVdBLE9BQU8sQ0FBQyxhQUFhO2dCQUMvRSxNQUFNQyxVQUFVLEdBQXVCSCxPQUFwQkEsT0FBT0ksUUFBUSxFQUFDLE1BQWdCLE9BQVpKLE9BQU9LLElBQUk7Z0JBRWxEM0IsT0FBT1EsT0FBTyxHQUFHbEIsb0RBQUVBLENBQUNtQyxTQUFTO29CQUMzQkcsTUFBTTt3QkFBRVY7b0JBQU07b0JBQ2RXLE9BQU87d0JBQUVYO29CQUFNO29CQUNmWSxZQUFZO3dCQUFDO3dCQUFhO3FCQUFVO29CQUNwQ0MsY0FBY2xDO29CQUNkbUMsbUJBQW1CbEM7b0JBQ25CbUMsc0JBQXNCbEM7b0JBQ3RCbUMsYUFBYTtnQkFDZjtnQkFFQWxDLE9BQU9RLE9BQU8sQ0FBQzJCLEVBQUUsQ0FBQzt5REFBVzt3QkFDM0IvQixlQUFlO3dCQUNmRSxnQkFBZ0I7d0JBQ2hCTCxXQUFXTyxPQUFPLEdBQUc7d0JBQ3JCZCxtQkFBQUEsNkJBQUFBO29CQUNGOztnQkFFQU0sT0FBT1EsT0FBTyxDQUFDMkIsRUFBRSxDQUFDO3lEQUFjLENBQUNDO3dCQUMvQmhDLGVBQWU7d0JBQ2ZFLGdCQUFnQjt3QkFDaEJYLG9CQUFBQSw4QkFBQUE7d0JBRUEsaUVBQWlFO3dCQUNqRSxJQUFJRSxhQUFhdUMsV0FBVywwQkFBMEJuQyxXQUFXTyxPQUFPLEdBQUdULFlBQVk7NEJBQ3JGRSxXQUFXTyxPQUFPLElBQUk7NEJBQ3RCTixpQkFBaUJNLE9BQU8sR0FBRzZCO3FFQUFXO29DQUNwQzlCO2dDQUNGO29FQUFHVDt3QkFDTDtvQkFDRjs7Z0JBRUFFLE9BQU9RLE9BQU8sQ0FBQzJCLEVBQUUsQ0FBQzt5REFBaUIsQ0FBQ0c7d0JBQ2xDaEMsZ0JBQWdCO3dCQUNoQmEsUUFBUW1CLEtBQUssQ0FBQywrQkFBK0JBO3dCQUM3QzFDLG9CQUFBQSw4QkFBQUEsUUFBVTBDO29CQUNaOztnQkFFQSx1RkFBdUY7Z0JBQ3ZGdEMsT0FBT1EsT0FBTyxDQUFDMkIsRUFBRSxDQUFDO3lEQUFTLENBQUNJO3dCQUMxQixJQUFJOUMsYUFBYThDLEtBQUtBLElBQUksRUFBRTs0QkFDMUI5QyxVQUFVO2dDQUNSK0MsTUFBTTtnQ0FDTkMsU0FBU0YsS0FBS0EsSUFBSTs0QkFDcEI7d0JBQ0Y7b0JBQ0Y7O2dCQUVBLDRCQUE0QjtnQkFDNUJ2QyxPQUFPUSxPQUFPLENBQUMyQixFQUFFLENBQUM7eURBQVcsQ0FBQ0k7d0JBQzVCLElBQUk5QyxhQUFhOEMsS0FBS0EsSUFBSSxFQUFFOzRCQUMxQjlDLFVBQVU7Z0NBQ1IrQyxNQUFNO2dDQUNOQyxTQUFTRixLQUFLQSxJQUFJOzRCQUNwQjt3QkFDRjtvQkFDRjs7Z0JBRUEsZ0RBQWdEO2dCQUNoRHZDLE9BQU9RLE9BQU8sQ0FBQ2tDLEtBQUs7eURBQUMsU0FBQ0M7eURBQWNDOzRCQUFBQTs7d0JBQ2xDLElBQUluRCxhQUFhbUQsS0FBS0MsTUFBTSxHQUFHLEdBQUc7NEJBQ2hDLE1BQU1KLFVBQVVHLElBQUksQ0FBQyxFQUFFOzRCQUN2QixJQUFJLE9BQU9ILFlBQVksWUFBWUEsWUFBWSxNQUFNO2dDQUNuRGhELFVBQVU7b0NBQ1IrQyxNQUFNRztvQ0FDTkYsU0FBUyxVQUFVQSxVQUFVQSxRQUFRRixJQUFJLEdBQUdFO2dDQUM5Qzs0QkFDRjt3QkFDRjtvQkFDRjs7WUFFRixFQUFFLE9BQU9ILE9BQU87Z0JBQ2RoQyxnQkFBZ0I7Z0JBQ2hCYSxRQUFRbUIsS0FBSyxDQUFDLGdDQUFnQ0E7Z0JBQzlDMUMsb0JBQUFBLDhCQUFBQSxRQUFVMEM7WUFDWjtRQUNGOzRDQUFHO1FBQUM5QztRQUFLQztRQUFXQztRQUFRQztRQUFTQztRQUFTQztRQUFXQztRQUFtQkM7S0FBVztJQUV2RixNQUFNK0MsYUFBYTFELGtEQUFXQTtnREFBQztZQUM3QixJQUFJYyxpQkFBaUJNLE9BQU8sRUFBRTtnQkFDNUJ1QyxhQUFhN0MsaUJBQWlCTSxPQUFPO1lBQ3ZDO1lBQ0EsSUFBSVIsT0FBT1EsT0FBTyxFQUFFO2dCQUNsQlIsT0FBT1EsT0FBTyxDQUFDc0MsVUFBVTtnQkFDekI5QyxPQUFPUSxPQUFPLEdBQUc7WUFDbkI7WUFDQUosZUFBZTtRQUNqQjsrQ0FBRyxFQUFFO0lBRUwsTUFBTTRDLE9BQU81RCxrREFBV0E7MENBQUMsQ0FBQ21EO2dCQUNwQnZDO1lBQUosS0FBSUEsa0JBQUFBLE9BQU9RLE9BQU8sY0FBZFIsc0NBQUFBLGdCQUFnQlMsU0FBUyxFQUFFO2dCQUM3QlQsT0FBT1EsT0FBTyxDQUFDeUMsSUFBSSxDQUFDVixLQUFLQyxJQUFJLEVBQUVELEtBQUtFLE9BQU87WUFDN0MsT0FBTztnQkFDTHRCLFFBQVFDLElBQUksQ0FBQztZQUNmO1FBQ0Y7eUNBQUcsRUFBRTtJQUVMbEMsZ0RBQVNBO2tDQUFDO1lBQ1JxQjtZQUVBOzBDQUFPO29CQUNMdUM7Z0JBQ0Y7O1FBQ0Y7aUNBQUc7UUFBQ3ZDO1FBQVN1QztLQUFXO0lBRXhCLE9BQU87UUFDTDNDO1FBQ0FFO1FBQ0FFO1FBQ0F1QztRQUNBRTtJQUNGO0FBQ0Y7QUFFQSx3QkFBd0I7QUFDakIsTUFBTUUsWUFBWTtJQUN2QixTQUFTO0lBQ1RDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFFaEIsVUFBVTtJQUNWQyxnQkFBZ0I7SUFFaEIsT0FBTztJQUNQQyxXQUFXO0lBRVgsS0FBSztJQUNMQyxrQkFBa0I7SUFDbEJDLG1CQUFtQjtJQUVuQixXQUFXO0lBQ1hDLGdCQUFnQjtJQUNoQkMsa0JBQWtCO0lBQ2xCQyxlQUFlO0FBQ2pCLEVBQVciLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZHVuY2FcXE9uZURyaXZlXFxEZXNrdG9wXFxBZWdpc1xcZnJvbnRlbmRcXHNyY1xcbGliXFx3ZWJzb2NrZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xyXG5cclxudHlwZSBXZWJTb2NrZXRNZXNzYWdlID0ge1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBwYXlsb2FkOiB1bmtub3duO1xyXG59O1xyXG5cclxuaW50ZXJmYWNlIFVzZVdlYlNvY2tldE9wdGlvbnMge1xyXG4gIHVybDogc3RyaW5nO1xyXG4gIG9uTWVzc2FnZT86IChtZXNzYWdlOiBXZWJTb2NrZXRNZXNzYWdlKSA9PiB2b2lkO1xyXG4gIG9uT3Blbj86ICgpID0+IHZvaWQ7XHJcbiAgb25DbG9zZT86ICgpID0+IHZvaWQ7XHJcbiAgb25FcnJvcj86IChlcnJvcjogRXZlbnQpID0+IHZvaWQ7XHJcbiAgcmVjb25uZWN0PzogYm9vbGVhbjtcclxuICByZWNvbm5lY3RJbnRlcnZhbD86IG51bWJlcjtcclxuICBtYXhSZXRyaWVzPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlV2ViU29ja2V0KHtcclxuICB1cmwsXHJcbiAgb25NZXNzYWdlLFxyXG4gIG9uT3BlbixcclxuICBvbkNsb3NlLFxyXG4gIG9uRXJyb3IsXHJcbiAgcmVjb25uZWN0ID0gdHJ1ZSxcclxuICByZWNvbm5lY3RJbnRlcnZhbCA9IDUwMDAsXHJcbiAgbWF4UmV0cmllcyA9IDUsXHJcbn06IFVzZVdlYlNvY2tldE9wdGlvbnMpIHtcclxuICBjb25zdCBzb2NrZXQgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgcmV0cnlDb3VudCA9IHVzZVJlZigwKTtcclxuICBjb25zdCByZWNvbm5lY3RUaW1lb3V0ID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW2lzQ29ubmVjdGVkLCBzZXRJc0Nvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2lzQ29ubmVjdGluZywgc2V0SXNDb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChzb2NrZXQuY3VycmVudD8uY29ubmVjdGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRJc0Nvbm5lY3RpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IEpXVCB0b2tlbiBmb3IgYXV0aGVudGljYXRpb25cclxuICAgICAgY29uc3QgZ2V0VG9rZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAvLyBUcnkgbG9jYWxTdG9yYWdlIGZpcnN0XHJcbiAgICAgICAgY29uc3QgbG9jYWxUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpO1xyXG4gICAgICAgIGlmIChsb2NhbFRva2VuKSByZXR1cm4gbG9jYWxUb2tlbjtcclxuICAgICAgICAvLyBUcnkgY29va2llIChpZiBub3QgSHR0cE9ubHkpXHJcbiAgICAgICAgY29uc3QgY29va2llTWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL2FjY2Vzc1Rva2VuPShbXjtdKykvKTtcclxuICAgICAgICBpZiAoY29va2llTWF0Y2gpIHJldHVybiBjb29raWVNYXRjaFsxXTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIEpXVCB0b2tlbiBhdmFpbGFibGUgZm9yIFdlYlNvY2tldCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICBvbkVycm9yPy4obmV3IEV2ZW50KCduby10b2tlbicpIGFzIGFueSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTb2NrZXQuSU8gY29ubmVjdGlvbiBvcHRpb25zXHJcbiAgICAgIC8vIEV4dHJhY3QgYmFzZSBVUkwgYW5kIG5hbWVzcGFjZSBmcm9tIHRoZSBwcm92aWRlZCBVUkxcclxuICAgICAgLy8gSWYgVVJMIGVuZHMgd2l0aCAvd3MsIHRyZWF0IC93cyBhcyB0aGUgbmFtZXNwYWNlXHJcbiAgICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsLnJlcGxhY2UoL153czpcXC9cXC8vLCAnaHR0cDovLycpLnJlcGxhY2UoL153c3M6XFwvXFwvLywgJ2h0dHBzOi8vJykpO1xyXG4gICAgICBjb25zdCBiYXNlVXJsID0gYCR7dXJsT2JqLnByb3RvY29sfS8vJHt1cmxPYmouaG9zdH1gO1xyXG4gICAgICBcclxuICAgICAgc29ja2V0LmN1cnJlbnQgPSBpbyhiYXNlVXJsLCB7XHJcbiAgICAgICAgYXV0aDogeyB0b2tlbiB9LFxyXG4gICAgICAgIHF1ZXJ5OiB7IHRva2VuIH0sXHJcbiAgICAgICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnLCAncG9sbGluZyddLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbjogcmVjb25uZWN0LFxyXG4gICAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiByZWNvbm5lY3RJbnRlcnZhbCxcclxuICAgICAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogbWF4UmV0cmllcyxcclxuICAgICAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHJ5Q291bnQuY3VycmVudCA9IDA7XHJcbiAgICAgICAgb25PcGVuPy4oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICBvbkNsb3NlPy4oKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBkaXNjb25uZWN0IHdhcyBub3QgaW50ZW50aW9uYWwsIGF0dGVtcHQgbWFudWFsIHJlY29ubmVjdGlvblxyXG4gICAgICAgIGlmIChyZWNvbm5lY3QgJiYgcmVhc29uICE9PSAnaW8gY2xpZW50IGRpc2Nvbm5lY3QnICYmIHJldHJ5Q291bnQuY3VycmVudCA8IG1heFJldHJpZXMpIHtcclxuICAgICAgICAgIHJldHJ5Q291bnQuY3VycmVudCArPSAxO1xyXG4gICAgICAgICAgcmVjb25uZWN0VGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm5lY3QoKTtcclxuICAgICAgICAgIH0sIHJlY29ubmVjdEludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc29ja2V0LmN1cnJlbnQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICBvbkVycm9yPy4oZXJyb3IgYXMgYW55KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBMaXN0ZW4gZm9yIGFsZXJ0IGV2ZW50cyAoYmFja2VuZCBlbWl0cyAnYWxlcnQnIHdpdGggeyBldmVudDogJ2FsZXJ0JywgZGF0YTogey4uLn0gfSlcclxuICAgICAgc29ja2V0LmN1cnJlbnQub24oJ2FsZXJ0JywgKGRhdGE6IHsgZXZlbnQ/OiBzdHJpbmc7IGRhdGE/OiB1bmtub3duIH0pID0+IHtcclxuICAgICAgICBpZiAob25NZXNzYWdlICYmIGRhdGEuZGF0YSkge1xyXG4gICAgICAgICAgb25NZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogJ2FsZXJ0JyxcclxuICAgICAgICAgICAgcGF5bG9hZDogZGF0YS5kYXRhLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIExpc3RlbiBmb3IgYW5vbWFseSBldmVudHNcclxuICAgICAgc29ja2V0LmN1cnJlbnQub24oJ2Fub21hbHknLCAoZGF0YTogeyBldmVudD86IHN0cmluZzsgZGF0YT86IHVua25vd24gfSkgPT4ge1xyXG4gICAgICAgIGlmIChvbk1lc3NhZ2UgJiYgZGF0YS5kYXRhKSB7XHJcbiAgICAgICAgICBvbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiAnYW5vbWFseScsXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEuZGF0YSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBHZW5lcmljIG1lc3NhZ2UgaGFuZGxlciBmb3Igb3RoZXIgZXZlbnQgdHlwZXNcclxuICAgICAgc29ja2V0LmN1cnJlbnQub25BbnkoKGV2ZW50TmFtZSwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGlmIChvbk1lc3NhZ2UgJiYgYXJncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgcGF5bG9hZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgIHR5cGU6IGV2ZW50TmFtZSxcclxuICAgICAgICAgICAgICBwYXlsb2FkOiAnZGF0YScgaW4gcGF5bG9hZCA/IHBheWxvYWQuZGF0YSA6IHBheWxvYWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgV2ViU29ja2V0OicsIGVycm9yKTtcclxuICAgICAgb25FcnJvcj8uKGVycm9yIGFzIGFueSk7XHJcbiAgICB9XHJcbiAgfSwgW3VybCwgb25NZXNzYWdlLCBvbk9wZW4sIG9uQ2xvc2UsIG9uRXJyb3IsIHJlY29ubmVjdCwgcmVjb25uZWN0SW50ZXJ2YWwsIG1heFJldHJpZXNdKTtcclxuXHJcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0LmN1cnJlbnQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXQuY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc29ja2V0LmN1cnJlbnQpIHtcclxuICAgICAgc29ja2V0LmN1cnJlbnQuZGlzY29ubmVjdCgpO1xyXG4gICAgICBzb2NrZXQuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBzZW5kID0gdXNlQ2FsbGJhY2soKGRhdGE6IFdlYlNvY2tldE1lc3NhZ2UpID0+IHtcclxuICAgIGlmIChzb2NrZXQuY3VycmVudD8uY29ubmVjdGVkKSB7XHJcbiAgICAgIHNvY2tldC5jdXJyZW50LmVtaXQoZGF0YS50eXBlLCBkYXRhLnBheWxvYWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS53YXJuKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbm5lY3QoKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkaXNjb25uZWN0KCk7XHJcbiAgICB9O1xyXG4gIH0sIFtjb25uZWN0LCBkaXNjb25uZWN0XSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpc0Nvbm5lY3RlZCxcclxuICAgIGlzQ29ubmVjdGluZyxcclxuICAgIGNvbm5lY3QsXHJcbiAgICBkaXNjb25uZWN0LFxyXG4gICAgc2VuZCxcclxuICB9O1xyXG59XHJcblxyXG4vLyBXZWJTb2NrZXQgZXZlbnQgdHlwZXNcclxuZXhwb3J0IGNvbnN0IFdTX0VWRU5UUyA9IHtcclxuICAvLyBBbGVydHNcclxuICBBTEVSVF9DUkVBVEVEOiAnYWxlcnQ6Y3JlYXRlZCcsXHJcbiAgQUxFUlRfVVBEQVRFRDogJ2FsZXJ0OnVwZGF0ZWQnLFxyXG4gIEFMRVJUX1JFU09MVkVEOiAnYWxlcnQ6cmVzb2x2ZWQnLFxyXG4gIFxyXG4gIC8vIE1ldHJpY3NcclxuICBNRVRSSUNTX1VQREFURTogJ21ldHJpY3M6dXBkYXRlJyxcclxuICBcclxuICAvLyBMb2dzXHJcbiAgTE9HX0VOVFJZOiAnbG9nOmVudHJ5JyxcclxuICBcclxuICAvLyBBSVxyXG4gIEFOT01BTFlfREVURUNURUQ6ICdhaTphbm9tYWx5X2RldGVjdGVkJyxcclxuICBQUkVESUNUSU9OX1VQREFURTogJ2FpOnByZWRpY3Rpb25fdXBkYXRlJyxcclxuICBcclxuICAvLyBFeGVjdXRvclxyXG4gIEFDVElPTl9TVEFSVEVEOiAnZXhlY3V0b3I6YWN0aW9uX3N0YXJ0ZWQnLFxyXG4gIEFDVElPTl9DT01QTEVURUQ6ICdleGVjdXRvcjphY3Rpb25fY29tcGxldGVkJyxcclxuICBBQ1RJT05fRkFJTEVEOiAnZXhlY3V0b3I6YWN0aW9uX2ZhaWxlZCcsXHJcbn0gYXMgY29uc3Q7XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZVN0YXRlIiwiaW8iLCJ1c2VXZWJTb2NrZXQiLCJ1cmwiLCJvbk1lc3NhZ2UiLCJvbk9wZW4iLCJvbkNsb3NlIiwib25FcnJvciIsInJlY29ubmVjdCIsInJlY29ubmVjdEludGVydmFsIiwibWF4UmV0cmllcyIsInNvY2tldCIsInJldHJ5Q291bnQiLCJyZWNvbm5lY3RUaW1lb3V0IiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImlzQ29ubmVjdGluZyIsInNldElzQ29ubmVjdGluZyIsImNvbm5lY3QiLCJjdXJyZW50IiwiY29ubmVjdGVkIiwiZ2V0VG9rZW4iLCJsb2NhbFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvb2tpZU1hdGNoIiwiZG9jdW1lbnQiLCJjb29raWUiLCJtYXRjaCIsInRva2VuIiwiY29uc29sZSIsIndhcm4iLCJFdmVudCIsInVybE9iaiIsIlVSTCIsInJlcGxhY2UiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwiYXV0aCIsInF1ZXJ5IiwidHJhbnNwb3J0cyIsInJlY29ubmVjdGlvbiIsInJlY29ubmVjdGlvbkRlbGF5IiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJhdXRvQ29ubmVjdCIsIm9uIiwicmVhc29uIiwic2V0VGltZW91dCIsImVycm9yIiwiZGF0YSIsInR5cGUiLCJwYXlsb2FkIiwib25BbnkiLCJldmVudE5hbWUiLCJhcmdzIiwibGVuZ3RoIiwiZGlzY29ubmVjdCIsImNsZWFyVGltZW91dCIsInNlbmQiLCJlbWl0IiwiV1NfRVZFTlRTIiwiQUxFUlRfQ1JFQVRFRCIsIkFMRVJUX1VQREFURUQiLCJBTEVSVF9SRVNPTFZFRCIsIk1FVFJJQ1NfVVBEQVRFIiwiTE9HX0VOVFJZIiwiQU5PTUFMWV9ERVRFQ1RFRCIsIlBSRURJQ1RJT05fVVBEQVRFIiwiQUNUSU9OX1NUQVJURUQiLCJBQ1RJT05fQ09NUExFVEVEIiwiQUNUSU9OX0ZBSUxFRCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/websocket.ts\n"));

/***/ })

});