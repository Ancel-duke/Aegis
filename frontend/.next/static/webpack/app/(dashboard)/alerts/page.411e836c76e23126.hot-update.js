"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/alerts/page",{

/***/ "(app-pages-browser)/./src/lib/websocket.ts":
/*!******************************!*\
  !*** ./src/lib/websocket.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WS_EVENTS: () => (/* binding */ WS_EVENTS),\n/* harmony export */   useWebSocket: () => (/* binding */ useWebSocket)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ useWebSocket,WS_EVENTS auto */ \n\nfunction useWebSocket(param) {\n    let { url, onMessage, onOpen, onClose, onError, reconnect = true, reconnectInterval = 5000, maxRetries = 5 } = param;\n    const socket = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const retryCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const reconnectTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isDisconnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Store callbacks in refs to avoid recreating connect/disconnect\n    const callbacksRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        onMessage,\n        onOpen,\n        onClose,\n        onError\n    });\n    const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        reconnect,\n        reconnectInterval,\n        maxRetries\n    });\n    // Update refs when callbacks/options change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWebSocket.useEffect\": ()=>{\n            callbacksRef.current = {\n                onMessage,\n                onOpen,\n                onClose,\n                onError\n            };\n            optionsRef.current = {\n                reconnect,\n                reconnectInterval,\n                maxRetries\n            };\n        }\n    }[\"useWebSocket.useEffect\"], [\n        onMessage,\n        onOpen,\n        onClose,\n        onError,\n        reconnect,\n        reconnectInterval,\n        maxRetries\n    ]);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[connect]\": ()=>{\n            var _socket_current;\n            // Prevent multiple simultaneous connection attempts\n            if (((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) || isConnecting || isDisconnectingRef.current) {\n                return;\n            }\n            setIsConnecting(true);\n            try {\n                // Get JWT token for authentication\n                const getToken = {\n                    \"useWebSocket.useCallback[connect].getToken\": ()=>{\n                        if (false) {}\n                        // Try localStorage first\n                        const localToken = localStorage.getItem('accessToken');\n                        if (localToken) return localToken;\n                        // Try cookie (if not HttpOnly)\n                        const cookieMatch = document.cookie.match(/accessToken=([^;]+)/);\n                        if (cookieMatch) return cookieMatch[1];\n                        return null;\n                    }\n                }[\"useWebSocket.useCallback[connect].getToken\"];\n                const token = getToken();\n                if (!token) {\n                    var _callbacksRef_current_onError, _callbacksRef_current;\n                    console.warn('No JWT token available for WebSocket connection');\n                    setIsConnecting(false);\n                    (_callbacksRef_current_onError = (_callbacksRef_current = callbacksRef.current).onError) === null || _callbacksRef_current_onError === void 0 ? void 0 : _callbacksRef_current_onError.call(_callbacksRef_current, new Event('no-token'));\n                    return;\n                }\n                // Socket.IO connection options\n                // Extract base URL - strip any path/namespace to connect to root namespace\n                // Socket.IO treats paths in the URL as namespaces, so we need just the base URL\n                const urlObj = new URL(url.replace(/^ws:\\/\\//, 'http://').replace(/^wss:\\/\\//, 'https://'));\n                const baseUrl = \"\".concat(urlObj.protocol, \"//\").concat(urlObj.host);\n                // Disconnect existing socket if any\n                if (socket.current) {\n                    socket.current.removeAllListeners();\n                    socket.current.disconnect();\n                    socket.current = null;\n                }\n                // Connect to root namespace (AlertsGateway is on root namespace)\n                socket.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(baseUrl, {\n                    auth: {\n                        token\n                    },\n                    query: {\n                        token\n                    },\n                    transports: [\n                        'websocket',\n                        'polling'\n                    ],\n                    reconnection: optionsRef.current.reconnect,\n                    reconnectionDelay: optionsRef.current.reconnectInterval,\n                    reconnectionAttempts: optionsRef.current.maxRetries,\n                    autoConnect: true\n                });\n                socket.current.on('connect', {\n                    \"useWebSocket.useCallback[connect]\": ()=>{\n                        var _callbacksRef_current_onOpen, _callbacksRef_current;\n                        setIsConnected(true);\n                        setIsConnecting(false);\n                        retryCount.current = 0;\n                        (_callbacksRef_current_onOpen = (_callbacksRef_current = callbacksRef.current).onOpen) === null || _callbacksRef_current_onOpen === void 0 ? void 0 : _callbacksRef_current_onOpen.call(_callbacksRef_current);\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('disconnect', {\n                    \"useWebSocket.useCallback[connect]\": (reason)=>{\n                        var _callbacksRef_current_onClose, _callbacksRef_current;\n                        setIsConnected(false);\n                        setIsConnecting(false);\n                        (_callbacksRef_current_onClose = (_callbacksRef_current = callbacksRef.current).onClose) === null || _callbacksRef_current_onClose === void 0 ? void 0 : _callbacksRef_current_onClose.call(_callbacksRef_current);\n                        // Only attempt manual reconnection if not intentionally disconnected\n                        if (!isDisconnectingRef.current && optionsRef.current.reconnect && reason !== 'io client disconnect' && retryCount.current < optionsRef.current.maxRetries) {\n                            retryCount.current += 1;\n                            reconnectTimeout.current = setTimeout({\n                                \"useWebSocket.useCallback[connect]\": ()=>{\n                                    if (!isDisconnectingRef.current) {\n                                        connect();\n                                    }\n                                }\n                            }[\"useWebSocket.useCallback[connect]\"], optionsRef.current.reconnectInterval);\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('connect_error', {\n                    \"useWebSocket.useCallback[connect]\": (error)=>{\n                        var _callbacksRef_current_onError, _callbacksRef_current;\n                        setIsConnecting(false);\n                        // Only log errors that aren't \"Invalid namespace\" to reduce noise\n                        if (error.message !== 'Invalid namespace') {\n                            console.error('WebSocket connection error:', error);\n                        }\n                        (_callbacksRef_current_onError = (_callbacksRef_current = callbacksRef.current).onError) === null || _callbacksRef_current_onError === void 0 ? void 0 : _callbacksRef_current_onError.call(_callbacksRef_current, error);\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for alert events (backend emits 'alert' with { event: 'alert', data: {...} })\n                socket.current.on('alert', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (callbacksRef.current.onMessage && data.data) {\n                            callbacksRef.current.onMessage({\n                                type: 'alert',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for anomaly events\n                socket.current.on('anomaly', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (callbacksRef.current.onMessage && data.data) {\n                            callbacksRef.current.onMessage({\n                                type: 'anomaly',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Generic message handler for other event types\n                socket.current.onAny({\n                    \"useWebSocket.useCallback[connect]\": function(eventName) {\n                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                            args[_key - 1] = arguments[_key];\n                        }\n                        if (callbacksRef.current.onMessage && args.length > 0) {\n                            const payload = args[0];\n                            if (typeof payload === 'object' && payload !== null) {\n                                callbacksRef.current.onMessage({\n                                    type: eventName,\n                                    payload: 'data' in payload ? payload.data : payload\n                                });\n                            }\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n            } catch (error) {\n                var _callbacksRef_current_onError1, _callbacksRef_current1;\n                setIsConnecting(false);\n                console.error('Failed to connect WebSocket:', error);\n                (_callbacksRef_current_onError1 = (_callbacksRef_current1 = callbacksRef.current).onError) === null || _callbacksRef_current_onError1 === void 0 ? void 0 : _callbacksRef_current_onError1.call(_callbacksRef_current1, error);\n            }\n        }\n    }[\"useWebSocket.useCallback[connect]\"], [\n        url,\n        isConnecting\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[disconnect]\": ()=>{\n            isDisconnectingRef.current = true;\n            if (reconnectTimeout.current) {\n                clearTimeout(reconnectTimeout.current);\n                reconnectTimeout.current = null;\n            }\n            if (socket.current) {\n                // Remove all listeners to prevent errors during disconnect\n                socket.current.removeAllListeners();\n                // Only disconnect if socket is actually connected or connecting\n                if (socket.current.connected || socket.current.connecting) {\n                    socket.current.disconnect();\n                }\n                socket.current = null;\n            }\n            setIsConnected(false);\n            setIsConnecting(false);\n            // Reset flag after a short delay to allow cleanup\n            setTimeout({\n                \"useWebSocket.useCallback[disconnect]\": ()=>{\n                    isDisconnectingRef.current = false;\n                }\n            }[\"useWebSocket.useCallback[disconnect]\"], 100);\n        }\n    }[\"useWebSocket.useCallback[disconnect]\"], []);\n    const send = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[send]\": (data)=>{\n            var _socket_current;\n            if ((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) {\n                socket.current.emit(data.type, data.payload);\n            } else {\n                console.warn('WebSocket is not connected');\n            }\n        }\n    }[\"useWebSocket.useCallback[send]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWebSocket.useEffect\": ()=>{\n            connect();\n            return ({\n                \"useWebSocket.useEffect\": ()=>{\n                    disconnect();\n                }\n            })[\"useWebSocket.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useWebSocket.useEffect\"], [\n        url\n    ]); // Only depend on url, not connect/disconnect\n    return {\n        isConnected,\n        isConnecting,\n        connect,\n        disconnect,\n        send\n    };\n}\n// WebSocket event types\nconst WS_EVENTS = {\n    // Alerts\n    ALERT_CREATED: 'alert:created',\n    ALERT_UPDATED: 'alert:updated',\n    ALERT_RESOLVED: 'alert:resolved',\n    // Metrics\n    METRICS_UPDATE: 'metrics:update',\n    // Logs\n    LOG_ENTRY: 'log:entry',\n    // AI\n    ANOMALY_DETECTED: 'ai:anomaly_detected',\n    PREDICTION_UPDATE: 'ai:prediction_update',\n    // Executor\n    ACTION_STARTED: 'executor:action_started',\n    ACTION_COMPLETED: 'executor:action_completed',\n    ACTION_FAILED: 'executor:action_failed'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDNkMsSUFBSSxDQUFDVixLQUFLQyxJQUFJLEVBQUVELEtBQUtFLE9BQU87WUFDN0MsT0FBTztnQkFDTHpCLFFBQVFDLElBQUksQ0FBQztZQUNmO1FBQ0Y7eUNBQUcsRUFBRTtJQUVMckMsZ0RBQVNBO2tDQUFDO1lBQ1J5QjtZQUVBOzBDQUFPO29CQUNMcUI7Z0JBQ0Y7O1FBQ0EsdURBQXVEO1FBQ3pEO2lDQUFHO1FBQUN4QztLQUFJLEdBQUcsNkNBQTZDO0lBRXhELE9BQU87UUFDTFk7UUFDQUU7UUFDQUs7UUFDQXFCO1FBQ0FzQjtJQUNGO0FBQ0Y7QUFFQSx3QkFBd0I7QUFDakIsTUFBTUUsWUFBWTtJQUN2QixTQUFTO0lBQ1RDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxnQkFBZ0I7SUFFaEIsVUFBVTtJQUNWQyxnQkFBZ0I7SUFFaEIsT0FBTztJQUNQQyxXQUFXO0lBRVgsS0FBSztJQUNMQyxrQkFBa0I7SUFDbEJDLG1CQUFtQjtJQUVuQixXQUFXO0lBQ1hDLGdCQUFnQjtJQUNoQkMsa0JBQWtCO0lBQ2xCQyxlQUFlO0FBQ2pCLEVBQVciLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZHVuY2FcXE9uZURyaXZlXFxEZXNrdG9wXFxBZWdpc1xcZnJvbnRlbmRcXHNyY1xcbGliXFx3ZWJzb2NrZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xyXG5cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xyXG5cclxudHlwZSBXZWJTb2NrZXRNZXNzYWdlID0ge1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBwYXlsb2FkOiB1bmtub3duO1xyXG59O1xyXG5cclxuaW50ZXJmYWNlIFVzZVdlYlNvY2tldE9wdGlvbnMge1xyXG4gIHVybDogc3RyaW5nO1xyXG4gIG9uTWVzc2FnZT86IChtZXNzYWdlOiBXZWJTb2NrZXRNZXNzYWdlKSA9PiB2b2lkO1xyXG4gIG9uT3Blbj86ICgpID0+IHZvaWQ7XHJcbiAgb25DbG9zZT86ICgpID0+IHZvaWQ7XHJcbiAgb25FcnJvcj86IChlcnJvcjogRXZlbnQpID0+IHZvaWQ7XHJcbiAgcmVjb25uZWN0PzogYm9vbGVhbjtcclxuICByZWNvbm5lY3RJbnRlcnZhbD86IG51bWJlcjtcclxuICBtYXhSZXRyaWVzPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlV2ViU29ja2V0KHtcclxuICB1cmwsXHJcbiAgb25NZXNzYWdlLFxyXG4gIG9uT3BlbixcclxuICBvbkNsb3NlLFxyXG4gIG9uRXJyb3IsXHJcbiAgcmVjb25uZWN0ID0gdHJ1ZSxcclxuICByZWNvbm5lY3RJbnRlcnZhbCA9IDUwMDAsXHJcbiAgbWF4UmV0cmllcyA9IDUsXHJcbn06IFVzZVdlYlNvY2tldE9wdGlvbnMpIHtcclxuICBjb25zdCBzb2NrZXQgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgcmV0cnlDb3VudCA9IHVzZVJlZigwKTtcclxuICBjb25zdCByZWNvbm5lY3RUaW1lb3V0ID0gdXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgaXNEaXNjb25uZWN0aW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbaXNDb25uZWN0aW5nLCBzZXRJc0Nvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIFxyXG4gIC8vIFN0b3JlIGNhbGxiYWNrcyBpbiByZWZzIHRvIGF2b2lkIHJlY3JlYXRpbmcgY29ubmVjdC9kaXNjb25uZWN0XHJcbiAgY29uc3QgY2FsbGJhY2tzUmVmID0gdXNlUmVmKHsgb25NZXNzYWdlLCBvbk9wZW4sIG9uQ2xvc2UsIG9uRXJyb3IgfSk7XHJcbiAgY29uc3Qgb3B0aW9uc1JlZiA9IHVzZVJlZih7IHJlY29ubmVjdCwgcmVjb25uZWN0SW50ZXJ2YWwsIG1heFJldHJpZXMgfSk7XHJcbiAgXHJcbiAgLy8gVXBkYXRlIHJlZnMgd2hlbiBjYWxsYmFja3Mvb3B0aW9ucyBjaGFuZ2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQgPSB7IG9uTWVzc2FnZSwgb25PcGVuLCBvbkNsb3NlLCBvbkVycm9yIH07XHJcbiAgICBvcHRpb25zUmVmLmN1cnJlbnQgPSB7IHJlY29ubmVjdCwgcmVjb25uZWN0SW50ZXJ2YWwsIG1heFJldHJpZXMgfTtcclxuICB9LCBbb25NZXNzYWdlLCBvbk9wZW4sIG9uQ2xvc2UsIG9uRXJyb3IsIHJlY29ubmVjdCwgcmVjb25uZWN0SW50ZXJ2YWwsIG1heFJldHJpZXNdKTtcclxuXHJcbiAgY29uc3QgY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgc2ltdWx0YW5lb3VzIGNvbm5lY3Rpb24gYXR0ZW1wdHNcclxuICAgIGlmIChzb2NrZXQuY3VycmVudD8uY29ubmVjdGVkIHx8IGlzQ29ubmVjdGluZyB8fCBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0SXNDb25uZWN0aW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCBKV1QgdG9rZW4gZm9yIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgIGNvbnN0IGdldFRva2VuID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gVHJ5IGxvY2FsU3RvcmFnZSBmaXJzdFxyXG4gICAgICAgIGNvbnN0IGxvY2FsVG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKTtcclxuICAgICAgICBpZiAobG9jYWxUb2tlbikgcmV0dXJuIGxvY2FsVG9rZW47XHJcbiAgICAgICAgLy8gVHJ5IGNvb2tpZSAoaWYgbm90IEh0dHBPbmx5KVxyXG4gICAgICAgIGNvbnN0IGNvb2tpZU1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC9hY2Nlc3NUb2tlbj0oW147XSspLyk7XHJcbiAgICAgICAgaWYgKGNvb2tpZU1hdGNoKSByZXR1cm4gY29va2llTWF0Y2hbMV07XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBKV1QgdG9rZW4gYXZhaWxhYmxlIGZvciBXZWJTb2NrZXQgY29ubmVjdGlvbicpO1xyXG4gICAgICAgIHNldElzQ29ubmVjdGluZyhmYWxzZSk7XHJcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25FcnJvcj8uKG5ldyBFdmVudCgnbm8tdG9rZW4nKSBhcyBhbnkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU29ja2V0LklPIGNvbm5lY3Rpb24gb3B0aW9uc1xyXG4gICAgICAvLyBFeHRyYWN0IGJhc2UgVVJMIC0gc3RyaXAgYW55IHBhdGgvbmFtZXNwYWNlIHRvIGNvbm5lY3QgdG8gcm9vdCBuYW1lc3BhY2VcclxuICAgICAgLy8gU29ja2V0LklPIHRyZWF0cyBwYXRocyBpbiB0aGUgVVJMIGFzIG5hbWVzcGFjZXMsIHNvIHdlIG5lZWQganVzdCB0aGUgYmFzZSBVUkxcclxuICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwucmVwbGFjZSgvXndzOlxcL1xcLy8sICdodHRwOi8vJykucmVwbGFjZSgvXndzczpcXC9cXC8vLCAnaHR0cHM6Ly8nKSk7XHJcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHt1cmxPYmoucHJvdG9jb2x9Ly8ke3VybE9iai5ob3N0fWA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEaXNjb25uZWN0IGV4aXN0aW5nIHNvY2tldCBpZiBhbnlcclxuICAgICAgaWYgKHNvY2tldC5jdXJyZW50KSB7XHJcbiAgICAgICAgc29ja2V0LmN1cnJlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgc29ja2V0LmN1cnJlbnQuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHNvY2tldC5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ29ubmVjdCB0byByb290IG5hbWVzcGFjZSAoQWxlcnRzR2F0ZXdheSBpcyBvbiByb290IG5hbWVzcGFjZSlcclxuICAgICAgc29ja2V0LmN1cnJlbnQgPSBpbyhiYXNlVXJsLCB7XHJcbiAgICAgICAgYXV0aDogeyB0b2tlbiB9LFxyXG4gICAgICAgIHF1ZXJ5OiB7IHRva2VuIH0sXHJcbiAgICAgICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnLCAncG9sbGluZyddLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbjogb3B0aW9uc1JlZi5jdXJyZW50LnJlY29ubmVjdCxcclxuICAgICAgICByZWNvbm5lY3Rpb25EZWxheTogb3B0aW9uc1JlZi5jdXJyZW50LnJlY29ubmVjdEludGVydmFsLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiBvcHRpb25zUmVmLmN1cnJlbnQubWF4UmV0cmllcyxcclxuICAgICAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHJ5Q291bnQuY3VycmVudCA9IDA7XHJcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25PcGVuPy4oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkNsb3NlPy4oKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBPbmx5IGF0dGVtcHQgbWFudWFsIHJlY29ubmVjdGlvbiBpZiBub3QgaW50ZW50aW9uYWxseSBkaXNjb25uZWN0ZWRcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAhaXNEaXNjb25uZWN0aW5nUmVmLmN1cnJlbnQgJiZcclxuICAgICAgICAgIG9wdGlvbnNSZWYuY3VycmVudC5yZWNvbm5lY3QgJiZcclxuICAgICAgICAgIHJlYXNvbiAhPT0gJ2lvIGNsaWVudCBkaXNjb25uZWN0JyAmJlxyXG4gICAgICAgICAgcmV0cnlDb3VudC5jdXJyZW50IDwgb3B0aW9uc1JlZi5jdXJyZW50Lm1heFJldHJpZXNcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHJ5Q291bnQuY3VycmVudCArPSAxO1xyXG4gICAgICAgICAgcmVjb25uZWN0VGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaXNEaXNjb25uZWN0aW5nUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIG9wdGlvbnNSZWYuY3VycmVudC5yZWNvbm5lY3RJbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNvY2tldC5jdXJyZW50Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICAvLyBPbmx5IGxvZyBlcnJvcnMgdGhhdCBhcmVuJ3QgXCJJbnZhbGlkIG5hbWVzcGFjZVwiIHRvIHJlZHVjZSBub2lzZVxyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlICE9PSAnSW52YWxpZCBuYW1lc3BhY2UnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uRXJyb3I/LihlcnJvciBhcyBhbnkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIExpc3RlbiBmb3IgYWxlcnQgZXZlbnRzIChiYWNrZW5kIGVtaXRzICdhbGVydCcgd2l0aCB7IGV2ZW50OiAnYWxlcnQnLCBkYXRhOiB7Li4ufSB9KVxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignYWxlcnQnLCAoZGF0YTogeyBldmVudD86IHN0cmluZzsgZGF0YT86IHVua25vd24gfSkgPT4ge1xyXG4gICAgICAgIGlmIChjYWxsYmFja3NSZWYuY3VycmVudC5vbk1lc3NhZ2UgJiYgZGF0YS5kYXRhKSB7XHJcbiAgICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiAnYWxlcnQnLFxyXG4gICAgICAgICAgICBwYXlsb2FkOiBkYXRhLmRhdGEsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gTGlzdGVuIGZvciBhbm9tYWx5IGV2ZW50c1xyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignYW5vbWFseScsIChkYXRhOiB7IGV2ZW50Pzogc3RyaW5nOyBkYXRhPzogdW5rbm93biB9KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSAmJiBkYXRhLmRhdGEpIHtcclxuICAgICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdhbm9tYWx5JyxcclxuICAgICAgICAgICAgcGF5bG9hZDogZGF0YS5kYXRhLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEdlbmVyaWMgbWVzc2FnZSBoYW5kbGVyIGZvciBvdGhlciBldmVudCB0eXBlc1xyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbkFueSgoZXZlbnROYW1lLCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBwYXlsb2FkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgdHlwZTogZXZlbnROYW1lLFxyXG4gICAgICAgICAgICAgIHBheWxvYWQ6ICdkYXRhJyBpbiBwYXlsb2FkID8gcGF5bG9hZC5kYXRhIDogcGF5bG9hZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCBXZWJTb2NrZXQ6JywgZXJyb3IpO1xyXG4gICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkVycm9yPy4oZXJyb3IgYXMgYW55KTtcclxuICAgIH1cclxuICB9LCBbdXJsLCBpc0Nvbm5lY3RpbmddKTtcclxuXHJcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXQuY3VycmVudCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dC5jdXJyZW50KTtcclxuICAgICAgcmVjb25uZWN0VGltZW91dC5jdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHNvY2tldC5jdXJyZW50KSB7XHJcbiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIHRvIHByZXZlbnQgZXJyb3JzIGR1cmluZyBkaXNjb25uZWN0XHJcbiAgICAgIHNvY2tldC5jdXJyZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgICBcclxuICAgICAgLy8gT25seSBkaXNjb25uZWN0IGlmIHNvY2tldCBpcyBhY3R1YWxseSBjb25uZWN0ZWQgb3IgY29ubmVjdGluZ1xyXG4gICAgICBpZiAoc29ja2V0LmN1cnJlbnQuY29ubmVjdGVkIHx8IHNvY2tldC5jdXJyZW50LmNvbm5lY3RpbmcpIHtcclxuICAgICAgICBzb2NrZXQuY3VycmVudC5kaXNjb25uZWN0KCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHNvY2tldC5jdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xyXG4gICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgIFxyXG4gICAgLy8gUmVzZXQgZmxhZyBhZnRlciBhIHNob3J0IGRlbGF5IHRvIGFsbG93IGNsZWFudXBcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgfSwgMTAwKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHNlbmQgPSB1c2VDYWxsYmFjaygoZGF0YTogV2ViU29ja2V0TWVzc2FnZSkgPT4ge1xyXG4gICAgaWYgKHNvY2tldC5jdXJyZW50Py5jb25uZWN0ZWQpIHtcclxuICAgICAgc29ja2V0LmN1cnJlbnQuZW1pdChkYXRhLnR5cGUsIGRhdGEucGF5bG9hZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29ubmVjdCgpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRpc2Nvbm5lY3QoKTtcclxuICAgIH07XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW3VybF0pOyAvLyBPbmx5IGRlcGVuZCBvbiB1cmwsIG5vdCBjb25uZWN0L2Rpc2Nvbm5lY3RcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlzQ29ubmVjdGVkLFxyXG4gICAgaXNDb25uZWN0aW5nLFxyXG4gICAgY29ubmVjdCxcclxuICAgIGRpc2Nvbm5lY3QsXHJcbiAgICBzZW5kLFxyXG4gIH07XHJcbn1cclxuXHJcbi8vIFdlYlNvY2tldCBldmVudCB0eXBlc1xyXG5leHBvcnQgY29uc3QgV1NfRVZFTlRTID0ge1xyXG4gIC8vIEFsZXJ0c1xyXG4gIEFMRVJUX0NSRUFURUQ6ICdhbGVydDpjcmVhdGVkJyxcclxuICBBTEVSVF9VUERBVEVEOiAnYWxlcnQ6dXBkYXRlZCcsXHJcbiAgQUxFUlRfUkVTT0xWRUQ6ICdhbGVydDpyZXNvbHZlZCcsXHJcbiAgXHJcbiAgLy8gTWV0cmljc1xyXG4gIE1FVFJJQ1NfVVBEQVRFOiAnbWV0cmljczp1cGRhdGUnLFxyXG4gIFxyXG4gIC8vIExvZ3NcclxuICBMT0dfRU5UUlk6ICdsb2c6ZW50cnknLFxyXG4gIFxyXG4gIC8vIEFJXHJcbiAgQU5PTUFMWV9ERVRFQ1RFRDogJ2FpOmFub21hbHlfZGV0ZWN0ZWQnLFxyXG4gIFBSRURJQ1RJT05fVVBEQVRFOiAnYWk6cHJlZGljdGlvbl91cGRhdGUnLFxyXG4gIFxyXG4gIC8vIEV4ZWN1dG9yXHJcbiAgQUNUSU9OX1NUQVJURUQ6ICdleGVjdXRvcjphY3Rpb25fc3RhcnRlZCcsXHJcbiAgQUNUSU9OX0NPTVBMRVRFRDogJ2V4ZWN1dG9yOmFjdGlvbl9jb21wbGV0ZWQnLFxyXG4gIEFDVElPTl9GQUlMRUQ6ICdleGVjdXRvcjphY3Rpb25fZmFpbGVkJyxcclxufSBhcyBjb25zdDtcclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlU3RhdGUiLCJpbyIsInVzZVdlYlNvY2tldCIsInVybCIsIm9uTWVzc2FnZSIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJvbkVycm9yIiwicmVjb25uZWN0IiwicmVjb25uZWN0SW50ZXJ2YWwiLCJtYXhSZXRyaWVzIiwic29ja2V0IiwicmV0cnlDb3VudCIsInJlY29ubmVjdFRpbWVvdXQiLCJpc0Rpc2Nvbm5lY3RpbmdSZWYiLCJpc0Nvbm5lY3RlZCIsInNldElzQ29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwic2V0SXNDb25uZWN0aW5nIiwiY2FsbGJhY2tzUmVmIiwib3B0aW9uc1JlZiIsImN1cnJlbnQiLCJjb25uZWN0IiwiY29ubmVjdGVkIiwiZ2V0VG9rZW4iLCJsb2NhbFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvb2tpZU1hdGNoIiwiZG9jdW1lbnQiLCJjb29raWUiLCJtYXRjaCIsInRva2VuIiwiY29uc29sZSIsIndhcm4iLCJFdmVudCIsInVybE9iaiIsIlVSTCIsInJlcGxhY2UiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZGlzY29ubmVjdCIsImF1dGgiLCJxdWVyeSIsInRyYW5zcG9ydHMiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwiYXV0b0Nvbm5lY3QiLCJvbiIsInJlYXNvbiIsInNldFRpbWVvdXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJkYXRhIiwidHlwZSIsInBheWxvYWQiLCJvbkFueSIsImV2ZW50TmFtZSIsImFyZ3MiLCJsZW5ndGgiLCJjbGVhclRpbWVvdXQiLCJjb25uZWN0aW5nIiwic2VuZCIsImVtaXQiLCJXU19FVkVOVFMiLCJBTEVSVF9DUkVBVEVEIiwiQUxFUlRfVVBEQVRFRCIsIkFMRVJUX1JFU09MVkVEIiwiTUVUUklDU19VUERBVEUiLCJMT0dfRU5UUlkiLCJBTk9NQUxZX0RFVEVDVEVEIiwiUFJFRElDVElPTl9VUERBVEUiLCJBQ1RJT05fU1RBUlRFRCIsIkFDVElPTl9DT01QTEVURUQiLCJBQ1RJT05fRkFJTEVEIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/websocket.ts\n"));

/***/ })

});