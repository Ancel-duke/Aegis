"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/alerts/page",{

/***/ "(app-pages-browser)/./src/lib/websocket.ts":
/*!******************************!*\
  !*** ./src/lib/websocket.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WS_EVENTS: () => (/* binding */ WS_EVENTS),\n/* harmony export */   useWebSocket: () => (/* binding */ useWebSocket)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ useWebSocket,WS_EVENTS auto */ \n\nfunction useWebSocket(param) {\n    let { url, onMessage, onOpen, onClose, onError, reconnect = true, reconnectInterval = 5000, maxRetries = 5 } = param;\n    const socket = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const retryCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const reconnectTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[connect]\": ()=>{\n            var _socket_current;\n            if ((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) {\n                return;\n            }\n            setIsConnecting(true);\n            try {\n                // Get JWT token for authentication\n                const getToken = {\n                    \"useWebSocket.useCallback[connect].getToken\": ()=>{\n                        if (false) {}\n                        // Try localStorage first\n                        const localToken = localStorage.getItem('accessToken');\n                        if (localToken) return localToken;\n                        // Try cookie (if not HttpOnly)\n                        const cookieMatch = document.cookie.match(/accessToken=([^;]+)/);\n                        if (cookieMatch) return cookieMatch[1];\n                        return null;\n                    }\n                }[\"useWebSocket.useCallback[connect].getToken\"];\n                const token = getToken();\n                if (!token) {\n                    console.warn('No JWT token available for WebSocket connection');\n                    setIsConnecting(false);\n                    onError === null || onError === void 0 ? void 0 : onError(new Event('no-token'));\n                    return;\n                }\n                // Socket.IO connection options\n                // Extract base URL and namespace from the provided URL\n                // If URL ends with /ws, treat /ws as the namespace\n                const urlObj = new URL(url.replace(/^ws:\\/\\//, 'http://').replace(/^wss:\\/\\//, 'https://'));\n                const namespace = urlObj.pathname || '/';\n                const baseUrl = \"\".concat(urlObj.protocol, \"//\").concat(urlObj.host);\n                socket.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(\"\".concat(baseUrl).concat(namespace), {\n                    auth: {\n                        token\n                    },\n                    query: {\n                        token\n                    },\n                    transports: [\n                        'websocket',\n                        'polling'\n                    ],\n                    reconnection: reconnect,\n                    reconnectionDelay: reconnectInterval,\n                    reconnectionAttempts: maxRetries,\n                    autoConnect: true\n                });\n                socket.current.on('connect', {\n                    \"useWebSocket.useCallback[connect]\": ()=>{\n                        setIsConnected(true);\n                        setIsConnecting(false);\n                        retryCount.current = 0;\n                        onOpen === null || onOpen === void 0 ? void 0 : onOpen();\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('disconnect', {\n                    \"useWebSocket.useCallback[connect]\": (reason)=>{\n                        setIsConnected(false);\n                        setIsConnecting(false);\n                        onClose === null || onClose === void 0 ? void 0 : onClose();\n                        // If disconnect was not intentional, attempt manual reconnection\n                        if (reconnect && reason !== 'io client disconnect' && retryCount.current < maxRetries) {\n                            retryCount.current += 1;\n                            reconnectTimeout.current = setTimeout({\n                                \"useWebSocket.useCallback[connect]\": ()=>{\n                                    connect();\n                                }\n                            }[\"useWebSocket.useCallback[connect]\"], reconnectInterval);\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('connect_error', {\n                    \"useWebSocket.useCallback[connect]\": (error)=>{\n                        setIsConnecting(false);\n                        console.error('WebSocket connection error:', error);\n                        onError === null || onError === void 0 ? void 0 : onError(error);\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for alert events (backend emits 'alert' with { event: 'alert', data: {...} })\n                socket.current.on('alert', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (onMessage && data.data) {\n                            onMessage({\n                                type: 'alert',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for anomaly events\n                socket.current.on('anomaly', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (onMessage && data.data) {\n                            onMessage({\n                                type: 'anomaly',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Generic message handler for other event types\n                socket.current.onAny({\n                    \"useWebSocket.useCallback[connect]\": function(eventName) {\n                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                            args[_key - 1] = arguments[_key];\n                        }\n                        if (onMessage && args.length > 0) {\n                            const payload = args[0];\n                            if (typeof payload === 'object' && payload !== null) {\n                                onMessage({\n                                    type: eventName,\n                                    payload: 'data' in payload ? payload.data : payload\n                                });\n                            }\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n            } catch (error) {\n                setIsConnecting(false);\n                console.error('Failed to connect WebSocket:', error);\n                onError === null || onError === void 0 ? void 0 : onError(error);\n            }\n        }\n    }[\"useWebSocket.useCallback[connect]\"], [\n        url,\n        onMessage,\n        onOpen,\n        onClose,\n        onError,\n        reconnect,\n        reconnectInterval,\n        maxRetries\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[disconnect]\": ()=>{\n            if (reconnectTimeout.current) {\n                clearTimeout(reconnectTimeout.current);\n            }\n            if (socket.current) {\n                socket.current.disconnect();\n                socket.current = null;\n            }\n            setIsConnected(false);\n        }\n    }[\"useWebSocket.useCallback[disconnect]\"], []);\n    const send = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[send]\": (data)=>{\n            var _socket_current;\n            if ((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) {\n                socket.current.emit(data.type, data.payload);\n            } else {\n                console.warn('WebSocket is not connected');\n            }\n        }\n    }[\"useWebSocket.useCallback[send]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWebSocket.useEffect\": ()=>{\n            connect();\n            return ({\n                \"useWebSocket.useEffect\": ()=>{\n                    disconnect();\n                }\n            })[\"useWebSocket.useEffect\"];\n        }\n    }[\"useWebSocket.useEffect\"], [\n        connect,\n        disconnect\n    ]);\n    return {\n        isConnected,\n        isConnecting,\n        connect,\n        disconnect,\n        send\n    };\n}\n// WebSocket event types\nconst WS_EVENTS = {\n    // Alerts\n    ALERT_CREATED: 'alert:created',\n    ALERT_UPDATED: 'alert:updated',\n    ALERT_RESOLVED: 'alert:resolved',\n    // Metrics\n    METRICS_UPDATE: 'metrics:update',\n    // Logs\n    LOG_ENTRY: 'log:entry',\n    // AI\n    ANOMALY_DETECTED: 'ai:anomaly_detected',\n    PREDICTION_UPDATE: 'ai:prediction_update',\n    // Executor\n    ACTION_STARTED: 'executor:action_started',\n    ACTION_COMPLETED: 'executor:action_completed',\n    ACTION_FAILED: 'executor:action_failed'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvd2Vic29ja2V0LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OzRFQUVpRTtBQUNuQjtBQWtCdkMsU0FBU0ssYUFBYSxLQVNQO1FBVE8sRUFDM0JDLEdBQUcsRUFDSEMsU0FBUyxFQUNUQyxNQUFNLEVBQ05DLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxZQUFZLElBQUksRUFDaEJDLG9CQUFvQixJQUFJLEVBQ3hCQyxhQUFhLENBQUMsRUFDTSxHQVRPO0lBVTNCLE1BQU1DLFNBQVNiLDZDQUFNQSxDQUFnQjtJQUNyQyxNQUFNYyxhQUFhZCw2Q0FBTUEsQ0FBQztJQUMxQixNQUFNZSxtQkFBbUJmLDZDQUFNQSxDQUF3QjtJQUN2RCxNQUFNLENBQUNnQixhQUFhQyxlQUFlLEdBQUdmLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2dCLGNBQWNDLGdCQUFnQixHQUFHakIsK0NBQVFBLENBQUM7SUFFakQsTUFBTWtCLFVBQVVuQixrREFBV0E7NkNBQUM7Z0JBQ3RCWTtZQUFKLEtBQUlBLGtCQUFBQSxPQUFPUSxPQUFPLGNBQWRSLHNDQUFBQSxnQkFBZ0JTLFNBQVMsRUFBRTtnQkFDN0I7WUFDRjtZQUVBSCxnQkFBZ0I7WUFFaEIsSUFBSTtnQkFDRixtQ0FBbUM7Z0JBQ25DLE1BQU1JO2tFQUFXO3dCQUNmLElBQUksS0FBNkIsRUFBRSxFQUFZO3dCQUMvQyx5QkFBeUI7d0JBQ3pCLE1BQU1DLGFBQWFDLGFBQWFDLE9BQU8sQ0FBQzt3QkFDeEMsSUFBSUYsWUFBWSxPQUFPQTt3QkFDdkIsK0JBQStCO3dCQUMvQixNQUFNRyxjQUFjQyxTQUFTQyxNQUFNLENBQUNDLEtBQUssQ0FBQzt3QkFDMUMsSUFBSUgsYUFBYSxPQUFPQSxXQUFXLENBQUMsRUFBRTt3QkFDdEMsT0FBTztvQkFDVDs7Z0JBRUEsTUFBTUksUUFBUVI7Z0JBRWQsSUFBSSxDQUFDUSxPQUFPO29CQUNWQyxRQUFRQyxJQUFJLENBQUM7b0JBQ2JkLGdCQUFnQjtv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SUFFdkYsTUFBTWlELGFBQWE1RCxrREFBV0E7Z0RBQUM7WUFDN0IsSUFBSWMsaUJBQWlCTSxPQUFPLEVBQUU7Z0JBQzVCeUMsYUFBYS9DLGlCQUFpQk0sT0FBTztZQUN2QztZQUNBLElBQUlSLE9BQU9RLE9BQU8sRUFBRTtnQkFDbEJSLE9BQU9RLE9BQU8sQ0FBQ3dDLFVBQVU7Z0JBQ3pCaEQsT0FBT1EsT0FBTyxHQUFHO1lBQ25CO1lBQ0FKLGVBQWU7UUFDakI7K0NBQUcsRUFBRTtJQUVMLE1BQU04QyxPQUFPOUQsa0RBQVdBOzBDQUFDLENBQUNxRDtnQkFDcEJ6QztZQUFKLEtBQUlBLGtCQUFBQSxPQUFPUSxPQUFPLGNBQWRSLHNDQUFBQSxnQkFBZ0JTLFNBQVMsRUFBRTtnQkFDN0JULE9BQU9RLE9BQU8sQ0FBQzJDLElBQUksQ0FBQ1YsS0FBS0MsSUFBSSxFQUFFRCxLQUFLRSxPQUFPO1lBQzdDLE9BQU87Z0JBQ0x4QixRQUFRQyxJQUFJLENBQUM7WUFDZjtRQUNGO3lDQUFHLEVBQUU7SUFFTGxDLGdEQUFTQTtrQ0FBQztZQUNScUI7WUFFQTswQ0FBTztvQkFDTHlDO2dCQUNGOztRQUNGO2lDQUFHO1FBQUN6QztRQUFTeUM7S0FBVztJQUV4QixPQUFPO1FBQ0w3QztRQUNBRTtRQUNBRTtRQUNBeUM7UUFDQUU7SUFDRjtBQUNGO0FBRUEsd0JBQXdCO0FBQ2pCLE1BQU1FLFlBQVk7SUFDdkIsU0FBUztJQUNUQyxlQUFlO0lBQ2ZDLGVBQWU7SUFDZkMsZ0JBQWdCO0lBRWhCLFVBQVU7SUFDVkMsZ0JBQWdCO0lBRWhCLE9BQU87SUFDUEMsV0FBVztJQUVYLEtBQUs7SUFDTEMsa0JBQWtCO0lBQ2xCQyxtQkFBbUI7SUFFbkIsV0FBVztJQUNYQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsZUFBZTtBQUNqQixFQUFXIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGR1bmNhXFxPbmVEcml2ZVxcRGVza3RvcFxcQWVnaXNcXGZyb250ZW5kXFxzcmNcXGxpYlxcd2Vic29ja2V0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcclxuXHJcbnR5cGUgV2ViU29ja2V0TWVzc2FnZSA9IHtcclxuICB0eXBlOiBzdHJpbmc7XHJcbiAgcGF5bG9hZDogdW5rbm93bjtcclxufTtcclxuXHJcbmludGVyZmFjZSBVc2VXZWJTb2NrZXRPcHRpb25zIHtcclxuICB1cmw6IHN0cmluZztcclxuICBvbk1lc3NhZ2U/OiAobWVzc2FnZTogV2ViU29ja2V0TWVzc2FnZSkgPT4gdm9pZDtcclxuICBvbk9wZW4/OiAoKSA9PiB2b2lkO1xyXG4gIG9uQ2xvc2U/OiAoKSA9PiB2b2lkO1xyXG4gIG9uRXJyb3I/OiAoZXJyb3I6IEV2ZW50KSA9PiB2b2lkO1xyXG4gIHJlY29ubmVjdD86IGJvb2xlYW47XHJcbiAgcmVjb25uZWN0SW50ZXJ2YWw/OiBudW1iZXI7XHJcbiAgbWF4UmV0cmllcz86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVdlYlNvY2tldCh7XHJcbiAgdXJsLFxyXG4gIG9uTWVzc2FnZSxcclxuICBvbk9wZW4sXHJcbiAgb25DbG9zZSxcclxuICBvbkVycm9yLFxyXG4gIHJlY29ubmVjdCA9IHRydWUsXHJcbiAgcmVjb25uZWN0SW50ZXJ2YWwgPSA1MDAwLFxyXG4gIG1heFJldHJpZXMgPSA1LFxyXG59OiBVc2VXZWJTb2NrZXRPcHRpb25zKSB7XHJcbiAgY29uc3Qgc29ja2V0ID0gdXNlUmVmPFNvY2tldCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IHJldHJ5Q291bnQgPSB1c2VSZWYoMCk7XHJcbiAgY29uc3QgcmVjb25uZWN0VGltZW91dCA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RpbmcsIHNldElzQ29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIGNvbnN0IGNvbm5lY3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoc29ja2V0LmN1cnJlbnQ/LmNvbm5lY3RlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0SXNDb25uZWN0aW5nKHRydWUpO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCBKV1QgdG9rZW4gZm9yIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgIGNvbnN0IGdldFRva2VuID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gVHJ5IGxvY2FsU3RvcmFnZSBmaXJzdFxyXG4gICAgICAgIGNvbnN0IGxvY2FsVG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWNjZXNzVG9rZW4nKTtcclxuICAgICAgICBpZiAobG9jYWxUb2tlbikgcmV0dXJuIGxvY2FsVG9rZW47XHJcbiAgICAgICAgLy8gVHJ5IGNvb2tpZSAoaWYgbm90IEh0dHBPbmx5KVxyXG4gICAgICAgIGNvbnN0IGNvb2tpZU1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC9hY2Nlc3NUb2tlbj0oW147XSspLyk7XHJcbiAgICAgICAgaWYgKGNvb2tpZU1hdGNoKSByZXR1cm4gY29va2llTWF0Y2hbMV07XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCB0b2tlbiA9IGdldFRva2VuKCk7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXRva2VuKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBKV1QgdG9rZW4gYXZhaWxhYmxlIGZvciBXZWJTb2NrZXQgY29ubmVjdGlvbicpO1xyXG4gICAgICAgIHNldElzQ29ubmVjdGluZyhmYWxzZSk7XHJcbiAgICAgICAgb25FcnJvcj8uKG5ldyBFdmVudCgnbm8tdG9rZW4nKSBhcyBhbnkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU29ja2V0LklPIGNvbm5lY3Rpb24gb3B0aW9uc1xyXG4gICAgICAvLyBFeHRyYWN0IGJhc2UgVVJMIGFuZCBuYW1lc3BhY2UgZnJvbSB0aGUgcHJvdmlkZWQgVVJMXHJcbiAgICAgIC8vIElmIFVSTCBlbmRzIHdpdGggL3dzLCB0cmVhdCAvd3MgYXMgdGhlIG5hbWVzcGFjZVxyXG4gICAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybC5yZXBsYWNlKC9ed3M6XFwvXFwvLywgJ2h0dHA6Ly8nKS5yZXBsYWNlKC9ed3NzOlxcL1xcLy8sICdodHRwczovLycpKTtcclxuICAgICAgY29uc3QgbmFtZXNwYWNlID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcvJztcclxuICAgICAgY29uc3QgYmFzZVVybCA9IGAke3VybE9iai5wcm90b2NvbH0vLyR7dXJsT2JqLmhvc3R9YDtcclxuICAgICAgXHJcbiAgICAgIHNvY2tldC5jdXJyZW50ID0gaW8oYCR7YmFzZVVybH0ke25hbWVzcGFjZX1gLCB7XHJcbiAgICAgICAgYXV0aDogeyB0b2tlbiB9LFxyXG4gICAgICAgIHF1ZXJ5OiB7IHRva2VuIH0sXHJcbiAgICAgICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnLCAncG9sbGluZyddLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbjogcmVjb25uZWN0LFxyXG4gICAgICAgIHJlY29ubmVjdGlvbkRlbGF5OiByZWNvbm5lY3RJbnRlcnZhbCxcclxuICAgICAgICByZWNvbm5lY3Rpb25BdHRlbXB0czogbWF4UmV0cmllcyxcclxuICAgICAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHJ5Q291bnQuY3VycmVudCA9IDA7XHJcbiAgICAgICAgb25PcGVuPy4oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICBvbkNsb3NlPy4oKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBkaXNjb25uZWN0IHdhcyBub3QgaW50ZW50aW9uYWwsIGF0dGVtcHQgbWFudWFsIHJlY29ubmVjdGlvblxyXG4gICAgICAgIGlmIChyZWNvbm5lY3QgJiYgcmVhc29uICE9PSAnaW8gY2xpZW50IGRpc2Nvbm5lY3QnICYmIHJldHJ5Q291bnQuY3VycmVudCA8IG1heFJldHJpZXMpIHtcclxuICAgICAgICAgIHJldHJ5Q291bnQuY3VycmVudCArPSAxO1xyXG4gICAgICAgICAgcmVjb25uZWN0VGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm5lY3QoKTtcclxuICAgICAgICAgIH0sIHJlY29ubmVjdEludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgc29ja2V0LmN1cnJlbnQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcclxuICAgICAgICBvbkVycm9yPy4oZXJyb3IgYXMgYW55KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBMaXN0ZW4gZm9yIGFsZXJ0IGV2ZW50cyAoYmFja2VuZCBlbWl0cyAnYWxlcnQnIHdpdGggeyBldmVudDogJ2FsZXJ0JywgZGF0YTogey4uLn0gfSlcclxuICAgICAgc29ja2V0LmN1cnJlbnQub24oJ2FsZXJ0JywgKGRhdGE6IHsgZXZlbnQ/OiBzdHJpbmc7IGRhdGE/OiB1bmtub3duIH0pID0+IHtcclxuICAgICAgICBpZiAob25NZXNzYWdlICYmIGRhdGEuZGF0YSkge1xyXG4gICAgICAgICAgb25NZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogJ2FsZXJ0JyxcclxuICAgICAgICAgICAgcGF5bG9hZDogZGF0YS5kYXRhLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIExpc3RlbiBmb3IgYW5vbWFseSBldmVudHNcclxuICAgICAgc29ja2V0LmN1cnJlbnQub24oJ2Fub21hbHknLCAoZGF0YTogeyBldmVudD86IHN0cmluZzsgZGF0YT86IHVua25vd24gfSkgPT4ge1xyXG4gICAgICAgIGlmIChvbk1lc3NhZ2UgJiYgZGF0YS5kYXRhKSB7XHJcbiAgICAgICAgICBvbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiAnYW5vbWFseScsXHJcbiAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEuZGF0YSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBHZW5lcmljIG1lc3NhZ2UgaGFuZGxlciBmb3Igb3RoZXIgZXZlbnQgdHlwZXNcclxuICAgICAgc29ja2V0LmN1cnJlbnQub25BbnkoKGV2ZW50TmFtZSwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGlmIChvbk1lc3NhZ2UgJiYgYXJncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gYXJnc1swXTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgcGF5bG9hZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgIHR5cGU6IGV2ZW50TmFtZSxcclxuICAgICAgICAgICAgICBwYXlsb2FkOiAnZGF0YScgaW4gcGF5bG9hZCA/IHBheWxvYWQuZGF0YSA6IHBheWxvYWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgV2ViU29ja2V0OicsIGVycm9yKTtcclxuICAgICAgb25FcnJvcj8uKGVycm9yIGFzIGFueSk7XHJcbiAgICB9XHJcbiAgfSwgW3VybCwgb25NZXNzYWdlLCBvbk9wZW4sIG9uQ2xvc2UsIG9uRXJyb3IsIHJlY29ubmVjdCwgcmVjb25uZWN0SW50ZXJ2YWwsIG1heFJldHJpZXNdKTtcclxuXHJcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlmIChyZWNvbm5lY3RUaW1lb3V0LmN1cnJlbnQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHJlY29ubmVjdFRpbWVvdXQuY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc29ja2V0LmN1cnJlbnQpIHtcclxuICAgICAgc29ja2V0LmN1cnJlbnQuZGlzY29ubmVjdCgpO1xyXG4gICAgICBzb2NrZXQuY3VycmVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBzZW5kID0gdXNlQ2FsbGJhY2soKGRhdGE6IFdlYlNvY2tldE1lc3NhZ2UpID0+IHtcclxuICAgIGlmIChzb2NrZXQuY3VycmVudD8uY29ubmVjdGVkKSB7XHJcbiAgICAgIHNvY2tldC5jdXJyZW50LmVtaXQoZGF0YS50eXBlLCBkYXRhLnBheWxvYWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uc29sZS53YXJuKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbm5lY3QoKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBkaXNjb25uZWN0KCk7XHJcbiAgICB9O1xyXG4gIH0sIFtjb25uZWN0LCBkaXNjb25uZWN0XSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBpc0Nvbm5lY3RlZCxcclxuICAgIGlzQ29ubmVjdGluZyxcclxuICAgIGNvbm5lY3QsXHJcbiAgICBkaXNjb25uZWN0LFxyXG4gICAgc2VuZCxcclxuICB9O1xyXG59XHJcblxyXG4vLyBXZWJTb2NrZXQgZXZlbnQgdHlwZXNcclxuZXhwb3J0IGNvbnN0IFdTX0VWRU5UUyA9IHtcclxuICAvLyBBbGVydHNcclxuICBBTEVSVF9DUkVBVEVEOiAnYWxlcnQ6Y3JlYXRlZCcsXHJcbiAgQUxFUlRfVVBEQVRFRDogJ2FsZXJ0OnVwZGF0ZWQnLFxyXG4gIEFMRVJUX1JFU09MVkVEOiAnYWxlcnQ6cmVzb2x2ZWQnLFxyXG4gIFxyXG4gIC8vIE1ldHJpY3NcclxuICBNRVRSSUNTX1VQREFURTogJ21ldHJpY3M6dXBkYXRlJyxcclxuICBcclxuICAvLyBMb2dzXHJcbiAgTE9HX0VOVFJZOiAnbG9nOmVudHJ5JyxcclxuICBcclxuICAvLyBBSVxyXG4gIEFOT01BTFlfREVURUNURUQ6ICdhaTphbm9tYWx5X2RldGVjdGVkJyxcclxuICBQUkVESUNUSU9OX1VQREFURTogJ2FpOnByZWRpY3Rpb25fdXBkYXRlJyxcclxuICBcclxuICAvLyBFeGVjdXRvclxyXG4gIEFDVElPTl9TVEFSVEVEOiAnZXhlY3V0b3I6YWN0aW9uX3N0YXJ0ZWQnLFxyXG4gIEFDVElPTl9DT01QTEVURUQ6ICdleGVjdXRvcjphY3Rpb25fY29tcGxldGVkJyxcclxuICBBQ1RJT05fRkFJTEVEOiAnZXhlY3V0b3I6YWN0aW9uX2ZhaWxlZCcsXHJcbn0gYXMgY29uc3Q7XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZVN0YXRlIiwiaW8iLCJ1c2VXZWJTb2NrZXQiLCJ1cmwiLCJvbk1lc3NhZ2UiLCJvbk9wZW4iLCJvbkNsb3NlIiwib25FcnJvciIsInJlY29ubmVjdCIsInJlY29ubmVjdEludGVydmFsIiwibWF4UmV0cmllcyIsInNvY2tldCIsInJldHJ5Q291bnQiLCJyZWNvbm5lY3RUaW1lb3V0IiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImlzQ29ubmVjdGluZyIsInNldElzQ29ubmVjdGluZyIsImNvbm5lY3QiLCJjdXJyZW50IiwiY29ubmVjdGVkIiwiZ2V0VG9rZW4iLCJsb2NhbFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvb2tpZU1hdGNoIiwiZG9jdW1lbnQiLCJjb29raWUiLCJtYXRjaCIsInRva2VuIiwiY29uc29sZSIsIndhcm4iLCJFdmVudCIsInVybE9iaiIsIlVSTCIsInJlcGxhY2UiLCJuYW1lc3BhY2UiLCJwYXRobmFtZSIsImJhc2VVcmwiLCJwcm90b2NvbCIsImhvc3QiLCJhdXRoIiwicXVlcnkiLCJ0cmFuc3BvcnRzIiwicmVjb25uZWN0aW9uIiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsImF1dG9Db25uZWN0Iiwib24iLCJyZWFzb24iLCJzZXRUaW1lb3V0IiwiZXJyb3IiLCJkYXRhIiwidHlwZSIsInBheWxvYWQiLCJvbkFueSIsImV2ZW50TmFtZSIsImFyZ3MiLCJsZW5ndGgiLCJkaXNjb25uZWN0IiwiY2xlYXJUaW1lb3V0Iiwic2VuZCIsImVtaXQiLCJXU19FVkVOVFMiLCJBTEVSVF9DUkVBVEVEIiwiQUxFUlRfVVBEQVRFRCIsIkFMRVJUX1JFU09MVkVEIiwiTUVUUklDU19VUERBVEUiLCJMT0dfRU5UUlkiLCJBTk9NQUxZX0RFVEVDVEVEIiwiUFJFRElDVElPTl9VUERBVEUiLCJBQ1RJT05fU1RBUlRFRCIsIkFDVElPTl9DT01QTEVURUQiLCJBQ1RJT05fRkFJTEVEIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/websocket.ts\n"));

/***/ })

});