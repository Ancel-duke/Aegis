"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/alerts/page",{

/***/ "(app-pages-browser)/./src/lib/websocket.ts":
/*!******************************!*\
  !*** ./src/lib/websocket.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WS_EVENTS: () => (/* binding */ WS_EVENTS),\n/* harmony export */   useWebSocket: () => (/* binding */ useWebSocket)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ useWebSocket,WS_EVENTS auto */ \n\nfunction useWebSocket(param) {\n    let { url, onMessage, onOpen, onClose, onError, reconnect = true, reconnectInterval = 5000, maxRetries = 5 } = param;\n    const socket = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const retryCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const reconnectTimeout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const isDisconnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isConnecting, setIsConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Store callbacks in refs to avoid recreating connect/disconnect\n    const callbacksRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        onMessage,\n        onOpen,\n        onClose,\n        onError\n    });\n    const optionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        reconnect,\n        reconnectInterval,\n        maxRetries\n    });\n    // Update refs when callbacks/options change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWebSocket.useEffect\": ()=>{\n            callbacksRef.current = {\n                onMessage,\n                onOpen,\n                onClose,\n                onError\n            };\n            optionsRef.current = {\n                reconnect,\n                reconnectInterval,\n                maxRetries\n            };\n        }\n    }[\"useWebSocket.useEffect\"], [\n        onMessage,\n        onOpen,\n        onClose,\n        onError,\n        reconnect,\n        reconnectInterval,\n        maxRetries\n    ]);\n    const connect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[connect]\": ()=>{\n            var _socket_current;\n            // Prevent multiple simultaneous connection attempts\n            if (((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) || isConnecting || isDisconnectingRef.current) {\n                return;\n            }\n            setIsConnecting(true);\n            try {\n                // Get JWT token for authentication\n                const getToken = {\n                    \"useWebSocket.useCallback[connect].getToken\": ()=>{\n                        if (false) {}\n                        // Try localStorage first\n                        const localToken = localStorage.getItem('accessToken');\n                        if (localToken) return localToken;\n                        // Try cookie (if not HttpOnly)\n                        const cookieMatch = document.cookie.match(/accessToken=([^;]+)/);\n                        if (cookieMatch) return cookieMatch[1];\n                        return null;\n                    }\n                }[\"useWebSocket.useCallback[connect].getToken\"];\n                const token = getToken();\n                if (!token) {\n                    var _callbacksRef_current_onError, _callbacksRef_current;\n                    console.warn('No JWT token available for WebSocket connection');\n                    setIsConnecting(false);\n                    (_callbacksRef_current_onError = (_callbacksRef_current = callbacksRef.current).onError) === null || _callbacksRef_current_onError === void 0 ? void 0 : _callbacksRef_current_onError.call(_callbacksRef_current, new Event('no-token'));\n                    return;\n                }\n                // Socket.IO connection options\n                // Extract base URL and namespace from the provided URL\n                const urlObj = new URL(url.replace(/^ws:\\/\\//, 'http://').replace(/^wss:\\/\\//, 'https://'));\n                const baseUrl = \"\".concat(urlObj.protocol, \"//\").concat(urlObj.host);\n                // Disconnect existing socket if any\n                if (socket.current) {\n                    socket.current.removeAllListeners();\n                    socket.current.disconnect();\n                    socket.current = null;\n                }\n                socket.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(baseUrl, {\n                    auth: {\n                        token\n                    },\n                    query: {\n                        token\n                    },\n                    transports: [\n                        'websocket',\n                        'polling'\n                    ],\n                    reconnection: optionsRef.current.reconnect,\n                    reconnectionDelay: optionsRef.current.reconnectInterval,\n                    reconnectionAttempts: optionsRef.current.maxRetries,\n                    autoConnect: true\n                });\n                socket.current.on('connect', {\n                    \"useWebSocket.useCallback[connect]\": ()=>{\n                        var _callbacksRef_current_onOpen, _callbacksRef_current;\n                        setIsConnected(true);\n                        setIsConnecting(false);\n                        retryCount.current = 0;\n                        (_callbacksRef_current_onOpen = (_callbacksRef_current = callbacksRef.current).onOpen) === null || _callbacksRef_current_onOpen === void 0 ? void 0 : _callbacksRef_current_onOpen.call(_callbacksRef_current);\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('disconnect', {\n                    \"useWebSocket.useCallback[connect]\": (reason)=>{\n                        var _callbacksRef_current_onClose, _callbacksRef_current;\n                        setIsConnected(false);\n                        setIsConnecting(false);\n                        (_callbacksRef_current_onClose = (_callbacksRef_current = callbacksRef.current).onClose) === null || _callbacksRef_current_onClose === void 0 ? void 0 : _callbacksRef_current_onClose.call(_callbacksRef_current);\n                        // Only attempt manual reconnection if not intentionally disconnected\n                        if (!isDisconnectingRef.current && optionsRef.current.reconnect && reason !== 'io client disconnect' && retryCount.current < optionsRef.current.maxRetries) {\n                            retryCount.current += 1;\n                            reconnectTimeout.current = setTimeout({\n                                \"useWebSocket.useCallback[connect]\": ()=>{\n                                    if (!isDisconnectingRef.current) {\n                                        connect();\n                                    }\n                                }\n                            }[\"useWebSocket.useCallback[connect]\"], optionsRef.current.reconnectInterval);\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                socket.current.on('connect_error', {\n                    \"useWebSocket.useCallback[connect]\": (error)=>{\n                        var _callbacksRef_current_onError, _callbacksRef_current;\n                        setIsConnecting(false);\n                        // Only log errors that aren't \"Invalid namespace\" to reduce noise\n                        if (error.message !== 'Invalid namespace') {\n                            console.error('WebSocket connection error:', error);\n                        }\n                        (_callbacksRef_current_onError = (_callbacksRef_current = callbacksRef.current).onError) === null || _callbacksRef_current_onError === void 0 ? void 0 : _callbacksRef_current_onError.call(_callbacksRef_current, error);\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for alert events (backend emits 'alert' with { event: 'alert', data: {...} })\n                socket.current.on('alert', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (callbacksRef.current.onMessage && data.data) {\n                            callbacksRef.current.onMessage({\n                                type: 'alert',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Listen for anomaly events\n                socket.current.on('anomaly', {\n                    \"useWebSocket.useCallback[connect]\": (data)=>{\n                        if (callbacksRef.current.onMessage && data.data) {\n                            callbacksRef.current.onMessage({\n                                type: 'anomaly',\n                                payload: data.data\n                            });\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n                // Generic message handler for other event types\n                socket.current.onAny({\n                    \"useWebSocket.useCallback[connect]\": function(eventName) {\n                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                            args[_key - 1] = arguments[_key];\n                        }\n                        if (callbacksRef.current.onMessage && args.length > 0) {\n                            const payload = args[0];\n                            if (typeof payload === 'object' && payload !== null) {\n                                callbacksRef.current.onMessage({\n                                    type: eventName,\n                                    payload: 'data' in payload ? payload.data : payload\n                                });\n                            }\n                        }\n                    }\n                }[\"useWebSocket.useCallback[connect]\"]);\n            } catch (error) {\n                var _callbacksRef_current_onError1, _callbacksRef_current1;\n                setIsConnecting(false);\n                console.error('Failed to connect WebSocket:', error);\n                (_callbacksRef_current_onError1 = (_callbacksRef_current1 = callbacksRef.current).onError) === null || _callbacksRef_current_onError1 === void 0 ? void 0 : _callbacksRef_current_onError1.call(_callbacksRef_current1, error);\n            }\n        }\n    }[\"useWebSocket.useCallback[connect]\"], [\n        url,\n        isConnecting\n    ]);\n    const disconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[disconnect]\": ()=>{\n            isDisconnectingRef.current = true;\n            if (reconnectTimeout.current) {\n                clearTimeout(reconnectTimeout.current);\n                reconnectTimeout.current = null;\n            }\n            if (socket.current) {\n                // Remove all listeners to prevent errors during disconnect\n                socket.current.removeAllListeners();\n                // Only disconnect if socket is actually connected or connecting\n                if (socket.current.connected || socket.current.connecting) {\n                    socket.current.disconnect();\n                }\n                socket.current = null;\n            }\n            setIsConnected(false);\n            setIsConnecting(false);\n            // Reset flag after a short delay to allow cleanup\n            setTimeout({\n                \"useWebSocket.useCallback[disconnect]\": ()=>{\n                    isDisconnectingRef.current = false;\n                }\n            }[\"useWebSocket.useCallback[disconnect]\"], 100);\n        }\n    }[\"useWebSocket.useCallback[disconnect]\"], []);\n    const send = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useWebSocket.useCallback[send]\": (data)=>{\n            var _socket_current;\n            if ((_socket_current = socket.current) === null || _socket_current === void 0 ? void 0 : _socket_current.connected) {\n                socket.current.emit(data.type, data.payload);\n            } else {\n                console.warn('WebSocket is not connected');\n            }\n        }\n    }[\"useWebSocket.useCallback[send]\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useWebSocket.useEffect\": ()=>{\n            connect();\n            return ({\n                \"useWebSocket.useEffect\": ()=>{\n                    disconnect();\n                }\n            })[\"useWebSocket.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"useWebSocket.useEffect\"], [\n        url\n    ]); // Only depend on url, not connect/disconnect\n    return {\n        isConnected,\n        isConnecting,\n        connect,\n        disconnect,\n        send\n    };\n}\n// WebSocket event types\nconst WS_EVENTS = {\n    // Alerts\n    ALERT_CREATED: 'alert:created',\n    ALERT_UPDATED: 'alert:updated',\n    ALERT_RESOLVED: 'alert:resolved',\n    // Metrics\n    METRICS_UPDATE: 'metrics:update',\n    // Logs\n    LOG_ENTRY: 'log:entry',\n    // AI\n    ANOMALY_DETECTED: 'ai:anomaly_detected',\n    PREDICTION_UPDATE: 'ai:prediction_update',\n    // Executor\n    ACTION_STARTED: 'executor:action_started',\n    ACTION_COMPLETED: 'executor:action_completed',\n    ACTION_FAILED: 'executor:action_failed'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksRUFBRUQsS0FBS0UsT0FBTztZQUM3QyxPQUFPO2dCQUNMekIsUUFBUUMsSUFBSSxDQUFDO1lBQ2Y7UUFDRjt5Q0FBRyxFQUFFO0lBRUxyQyxnREFBU0E7a0NBQUM7WUFDUnlCO1lBRUE7MENBQU87b0JBQ0xxQjtnQkFDRjs7UUFDQSx1REFBdUQ7UUFDekQ7aUNBQUc7UUFBQ3hDO0tBQUksR0FBRyw2Q0FBNkM7SUFFeEQsT0FBTztRQUNMWTtRQUNBRTtRQUNBSztRQUNBcUI7UUFDQXNCO0lBQ0Y7QUFDRjtBQUVBLHdCQUF3QjtBQUNqQixNQUFNRSxZQUFZO0lBQ3ZCLFNBQVM7SUFDVEMsZUFBZTtJQUNmQyxlQUFlO0lBQ2ZDLGdCQUFnQjtJQUVoQixVQUFVO0lBQ1ZDLGdCQUFnQjtJQUVoQixPQUFPO0lBQ1BDLFdBQVc7SUFFWCxLQUFLO0lBQ0xDLGtCQUFrQjtJQUNsQkMsbUJBQW1CO0lBRW5CLFdBQVc7SUFDWEMsZ0JBQWdCO0lBQ2hCQyxrQkFBa0I7SUFDbEJDLGVBQWU7QUFDakIsRUFBVyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxkdW5jYVxcT25lRHJpdmVcXERlc2t0b3BcXEFlZ2lzXFxmcm9udGVuZFxcc3JjXFxsaWJcXHdlYnNvY2tldC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XHJcblxyXG50eXBlIFdlYlNvY2tldE1lc3NhZ2UgPSB7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG4gIHBheWxvYWQ6IHVua25vd247XHJcbn07XHJcblxyXG5pbnRlcmZhY2UgVXNlV2ViU29ja2V0T3B0aW9ucyB7XHJcbiAgdXJsOiBzdHJpbmc7XHJcbiAgb25NZXNzYWdlPzogKG1lc3NhZ2U6IFdlYlNvY2tldE1lc3NhZ2UpID0+IHZvaWQ7XHJcbiAgb25PcGVuPzogKCkgPT4gdm9pZDtcclxuICBvbkNsb3NlPzogKCkgPT4gdm9pZDtcclxuICBvbkVycm9yPzogKGVycm9yOiBFdmVudCkgPT4gdm9pZDtcclxuICByZWNvbm5lY3Q/OiBib29sZWFuO1xyXG4gIHJlY29ubmVjdEludGVydmFsPzogbnVtYmVyO1xyXG4gIG1heFJldHJpZXM/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VXZWJTb2NrZXQoe1xyXG4gIHVybCxcclxuICBvbk1lc3NhZ2UsXHJcbiAgb25PcGVuLFxyXG4gIG9uQ2xvc2UsXHJcbiAgb25FcnJvcixcclxuICByZWNvbm5lY3QgPSB0cnVlLFxyXG4gIHJlY29ubmVjdEludGVydmFsID0gNTAwMCxcclxuICBtYXhSZXRyaWVzID0gNSxcclxufTogVXNlV2ViU29ja2V0T3B0aW9ucykge1xyXG4gIGNvbnN0IHNvY2tldCA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCByZXRyeUNvdW50ID0gdXNlUmVmKDApO1xyXG4gIGNvbnN0IHJlY29ubmVjdFRpbWVvdXQgPSB1c2VSZWY8Tm9kZUpTLlRpbWVvdXQgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBpc0Rpc2Nvbm5lY3RpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RlZCwgc2V0SXNDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0Nvbm5lY3RpbmcsIHNldElzQ29ubmVjdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgXHJcbiAgLy8gU3RvcmUgY2FsbGJhY2tzIGluIHJlZnMgdG8gYXZvaWQgcmVjcmVhdGluZyBjb25uZWN0L2Rpc2Nvbm5lY3RcclxuICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoeyBvbk1lc3NhZ2UsIG9uT3Blbiwgb25DbG9zZSwgb25FcnJvciB9KTtcclxuICBjb25zdCBvcHRpb25zUmVmID0gdXNlUmVmKHsgcmVjb25uZWN0LCByZWNvbm5lY3RJbnRlcnZhbCwgbWF4UmV0cmllcyB9KTtcclxuICBcclxuICAvLyBVcGRhdGUgcmVmcyB3aGVuIGNhbGxiYWNrcy9vcHRpb25zIGNoYW5nZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjYWxsYmFja3NSZWYuY3VycmVudCA9IHsgb25NZXNzYWdlLCBvbk9wZW4sIG9uQ2xvc2UsIG9uRXJyb3IgfTtcclxuICAgIG9wdGlvbnNSZWYuY3VycmVudCA9IHsgcmVjb25uZWN0LCByZWNvbm5lY3RJbnRlcnZhbCwgbWF4UmV0cmllcyB9O1xyXG4gIH0sIFtvbk1lc3NhZ2UsIG9uT3Blbiwgb25DbG9zZSwgb25FcnJvciwgcmVjb25uZWN0LCByZWNvbm5lY3RJbnRlcnZhbCwgbWF4UmV0cmllc10pO1xyXG5cclxuICBjb25zdCBjb25uZWN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgLy8gUHJldmVudCBtdWx0aXBsZSBzaW11bHRhbmVvdXMgY29ubmVjdGlvbiBhdHRlbXB0c1xyXG4gICAgaWYgKHNvY2tldC5jdXJyZW50Py5jb25uZWN0ZWQgfHwgaXNDb25uZWN0aW5nIHx8IGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBzZXRJc0Nvbm5lY3RpbmcodHJ1ZSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IEpXVCB0b2tlbiBmb3IgYXV0aGVudGljYXRpb25cclxuICAgICAgY29uc3QgZ2V0VG9rZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAvLyBUcnkgbG9jYWxTdG9yYWdlIGZpcnN0XHJcbiAgICAgICAgY29uc3QgbG9jYWxUb2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhY2Nlc3NUb2tlbicpO1xyXG4gICAgICAgIGlmIChsb2NhbFRva2VuKSByZXR1cm4gbG9jYWxUb2tlbjtcclxuICAgICAgICAvLyBUcnkgY29va2llIChpZiBub3QgSHR0cE9ubHkpXHJcbiAgICAgICAgY29uc3QgY29va2llTWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL2FjY2Vzc1Rva2VuPShbXjtdKykvKTtcclxuICAgICAgICBpZiAoY29va2llTWF0Y2gpIHJldHVybiBjb29raWVNYXRjaFsxXTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGNvbnN0IHRva2VuID0gZ2V0VG9rZW4oKTtcclxuICAgICAgXHJcbiAgICAgIGlmICghdG9rZW4pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIEpXVCB0b2tlbiBhdmFpbGFibGUgZm9yIFdlYlNvY2tldCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkVycm9yPy4obmV3IEV2ZW50KCduby10b2tlbicpIGFzIGFueSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTb2NrZXQuSU8gY29ubmVjdGlvbiBvcHRpb25zXHJcbiAgICAgIC8vIEV4dHJhY3QgYmFzZSBVUkwgYW5kIG5hbWVzcGFjZSBmcm9tIHRoZSBwcm92aWRlZCBVUkxcclxuICAgICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTCh1cmwucmVwbGFjZSgvXndzOlxcL1xcLy8sICdodHRwOi8vJykucmVwbGFjZSgvXndzczpcXC9cXC8vLCAnaHR0cHM6Ly8nKSk7XHJcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSBgJHt1cmxPYmoucHJvdG9jb2x9Ly8ke3VybE9iai5ob3N0fWA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEaXNjb25uZWN0IGV4aXN0aW5nIHNvY2tldCBpZiBhbnlcclxuICAgICAgaWYgKHNvY2tldC5jdXJyZW50KSB7XHJcbiAgICAgICAgc29ja2V0LmN1cnJlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgc29ja2V0LmN1cnJlbnQuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIHNvY2tldC5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgc29ja2V0LmN1cnJlbnQgPSBpbyhiYXNlVXJsLCB7XHJcbiAgICAgICAgYXV0aDogeyB0b2tlbiB9LFxyXG4gICAgICAgIHF1ZXJ5OiB7IHRva2VuIH0sXHJcbiAgICAgICAgdHJhbnNwb3J0czogWyd3ZWJzb2NrZXQnLCAncG9sbGluZyddLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbjogb3B0aW9uc1JlZi5jdXJyZW50LnJlY29ubmVjdCxcclxuICAgICAgICByZWNvbm5lY3Rpb25EZWxheTogb3B0aW9uc1JlZi5jdXJyZW50LnJlY29ubmVjdEludGVydmFsLFxyXG4gICAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiBvcHRpb25zUmVmLmN1cnJlbnQubWF4UmV0cmllcyxcclxuICAgICAgICBhdXRvQ29ubmVjdDogdHJ1ZSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICAgIHJldHJ5Q291bnQuY3VycmVudCA9IDA7XHJcbiAgICAgICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25PcGVuPy4oKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcclxuICAgICAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkNsb3NlPy4oKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBPbmx5IGF0dGVtcHQgbWFudWFsIHJlY29ubmVjdGlvbiBpZiBub3QgaW50ZW50aW9uYWxseSBkaXNjb25uZWN0ZWRcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAhaXNEaXNjb25uZWN0aW5nUmVmLmN1cnJlbnQgJiZcclxuICAgICAgICAgIG9wdGlvbnNSZWYuY3VycmVudC5yZWNvbm5lY3QgJiZcclxuICAgICAgICAgIHJlYXNvbiAhPT0gJ2lvIGNsaWVudCBkaXNjb25uZWN0JyAmJlxyXG4gICAgICAgICAgcmV0cnlDb3VudC5jdXJyZW50IDwgb3B0aW9uc1JlZi5jdXJyZW50Lm1heFJldHJpZXNcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHJ5Q291bnQuY3VycmVudCArPSAxO1xyXG4gICAgICAgICAgcmVjb25uZWN0VGltZW91dC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaXNEaXNjb25uZWN0aW5nUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICBjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIG9wdGlvbnNSZWYuY3VycmVudC5yZWNvbm5lY3RJbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHNvY2tldC5jdXJyZW50Lm9uKCdjb25uZWN0X2Vycm9yJywgKGVycm9yKSA9PiB7XHJcbiAgICAgICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgICAgICAvLyBPbmx5IGxvZyBlcnJvcnMgdGhhdCBhcmVuJ3QgXCJJbnZhbGlkIG5hbWVzcGFjZVwiIHRvIHJlZHVjZSBub2lzZVxyXG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlICE9PSAnSW52YWxpZCBuYW1lc3BhY2UnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJTb2NrZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uRXJyb3I/LihlcnJvciBhcyBhbnkpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIExpc3RlbiBmb3IgYWxlcnQgZXZlbnRzIChiYWNrZW5kIGVtaXRzICdhbGVydCcgd2l0aCB7IGV2ZW50OiAnYWxlcnQnLCBkYXRhOiB7Li4ufSB9KVxyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignYWxlcnQnLCAoZGF0YTogeyBldmVudD86IHN0cmluZzsgZGF0YT86IHVua25vd24gfSkgPT4ge1xyXG4gICAgICAgIGlmIChjYWxsYmFja3NSZWYuY3VycmVudC5vbk1lc3NhZ2UgJiYgZGF0YS5kYXRhKSB7XHJcbiAgICAgICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbk1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiAnYWxlcnQnLFxyXG4gICAgICAgICAgICBwYXlsb2FkOiBkYXRhLmRhdGEsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gTGlzdGVuIGZvciBhbm9tYWx5IGV2ZW50c1xyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbignYW5vbWFseScsIChkYXRhOiB7IGV2ZW50Pzogc3RyaW5nOyBkYXRhPzogdW5rbm93biB9KSA9PiB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSAmJiBkYXRhLmRhdGEpIHtcclxuICAgICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHR5cGU6ICdhbm9tYWx5JyxcclxuICAgICAgICAgICAgcGF5bG9hZDogZGF0YS5kYXRhLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEdlbmVyaWMgbWVzc2FnZSBoYW5kbGVyIGZvciBvdGhlciBldmVudCB0eXBlc1xyXG4gICAgICBzb2NrZXQuY3VycmVudC5vbkFueSgoZXZlbnROYW1lLCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBwYXlsb2FkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrc1JlZi5jdXJyZW50Lm9uTWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgdHlwZTogZXZlbnROYW1lLFxyXG4gICAgICAgICAgICAgIHBheWxvYWQ6ICdkYXRhJyBpbiBwYXlsb2FkID8gcGF5bG9hZC5kYXRhIDogcGF5bG9hZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBzZXRJc0Nvbm5lY3RpbmcoZmFsc2UpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCBXZWJTb2NrZXQ6JywgZXJyb3IpO1xyXG4gICAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkVycm9yPy4oZXJyb3IgYXMgYW55KTtcclxuICAgIH1cclxuICB9LCBbdXJsLCBpc0Nvbm5lY3RpbmddKTtcclxuXHJcbiAgY29uc3QgZGlzY29ubmVjdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGlzRGlzY29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgaWYgKHJlY29ubmVjdFRpbWVvdXQuY3VycmVudCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZW91dC5jdXJyZW50KTtcclxuICAgICAgcmVjb25uZWN0VGltZW91dC5jdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHNvY2tldC5jdXJyZW50KSB7XHJcbiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIHRvIHByZXZlbnQgZXJyb3JzIGR1cmluZyBkaXNjb25uZWN0XHJcbiAgICAgIHNvY2tldC5jdXJyZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgICBcclxuICAgICAgLy8gT25seSBkaXNjb25uZWN0IGlmIHNvY2tldCBpcyBhY3R1YWxseSBjb25uZWN0ZWQgb3IgY29ubmVjdGluZ1xyXG4gICAgICBpZiAoc29ja2V0LmN1cnJlbnQuY29ubmVjdGVkIHx8IHNvY2tldC5jdXJyZW50LmNvbm5lY3RpbmcpIHtcclxuICAgICAgICBzb2NrZXQuY3VycmVudC5kaXNjb25uZWN0KCk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHNvY2tldC5jdXJyZW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgc2V0SXNDb25uZWN0ZWQoZmFsc2UpO1xyXG4gICAgc2V0SXNDb25uZWN0aW5nKGZhbHNlKTtcclxuICAgIFxyXG4gICAgLy8gUmVzZXQgZmxhZyBhZnRlciBhIHNob3J0IGRlbGF5IHRvIGFsbG93IGNsZWFudXBcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgfSwgMTAwKTtcclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHNlbmQgPSB1c2VDYWxsYmFjaygoZGF0YTogV2ViU29ja2V0TWVzc2FnZSkgPT4ge1xyXG4gICAgaWYgKHNvY2tldC5jdXJyZW50Py5jb25uZWN0ZWQpIHtcclxuICAgICAgc29ja2V0LmN1cnJlbnQuZW1pdChkYXRhLnR5cGUsIGRhdGEucGF5bG9hZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29ubmVjdCgpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGRpc2Nvbm5lY3QoKTtcclxuICAgIH07XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgfSwgW3VybF0pOyAvLyBPbmx5IGRlcGVuZCBvbiB1cmwsIG5vdCBjb25uZWN0L2Rpc2Nvbm5lY3RcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGlzQ29ubmVjdGVkLFxyXG4gICAgaXNDb25uZWN0aW5nLFxyXG4gICAgY29ubmVjdCxcclxuICAgIGRpc2Nvbm5lY3QsXHJcbiAgICBzZW5kLFxyXG4gIH07XHJcbn1cclxuXHJcbi8vIFdlYlNvY2tldCBldmVudCB0eXBlc1xyXG5leHBvcnQgY29uc3QgV1NfRVZFTlRTID0ge1xyXG4gIC8vIEFsZXJ0c1xyXG4gIEFMRVJUX0NSRUFURUQ6ICdhbGVydDpjcmVhdGVkJyxcclxuICBBTEVSVF9VUERBVEVEOiAnYWxlcnQ6dXBkYXRlZCcsXHJcbiAgQUxFUlRfUkVTT0xWRUQ6ICdhbGVydDpyZXNvbHZlZCcsXHJcbiAgXHJcbiAgLy8gTWV0cmljc1xyXG4gIE1FVFJJQ1NfVVBEQVRFOiAnbWV0cmljczp1cGRhdGUnLFxyXG4gIFxyXG4gIC8vIExvZ3NcclxuICBMT0dfRU5UUlk6ICdsb2c6ZW50cnknLFxyXG4gIFxyXG4gIC8vIEFJXHJcbiAgQU5PTUFMWV9ERVRFQ1RFRDogJ2FpOmFub21hbHlfZGV0ZWN0ZWQnLFxyXG4gIFBSRURJQ1RJT05fVVBEQVRFOiAnYWk6cHJlZGljdGlvbl91cGRhdGUnLFxyXG4gIFxyXG4gIC8vIEV4ZWN1dG9yXHJcbiAgQUNUSU9OX1NUQVJURUQ6ICdleGVjdXRvcjphY3Rpb25fc3RhcnRlZCcsXHJcbiAgQUNUSU9OX0NPTVBMRVRFRDogJ2V4ZWN1dG9yOmFjdGlvbl9jb21wbGV0ZWQnLFxyXG4gIEFDVElPTl9GQUlMRUQ6ICdleGVjdXRvcjphY3Rpb25fZmFpbGVkJyxcclxufSBhcyBjb25zdDtcclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlU3RhdGUiLCJpbyIsInVzZVdlYlNvY2tldCIsInVybCIsIm9uTWVzc2FnZSIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJvbkVycm9yIiwicmVjb25uZWN0IiwicmVjb25uZWN0SW50ZXJ2YWwiLCJtYXhSZXRyaWVzIiwic29ja2V0IiwicmV0cnlDb3VudCIsInJlY29ubmVjdFRpbWVvdXQiLCJpc0Rpc2Nvbm5lY3RpbmdSZWYiLCJpc0Nvbm5lY3RlZCIsInNldElzQ29ubmVjdGVkIiwiaXNDb25uZWN0aW5nIiwic2V0SXNDb25uZWN0aW5nIiwiY2FsbGJhY2tzUmVmIiwib3B0aW9uc1JlZiIsImN1cnJlbnQiLCJjb25uZWN0IiwiY29ubmVjdGVkIiwiZ2V0VG9rZW4iLCJsb2NhbFRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvb2tpZU1hdGNoIiwiZG9jdW1lbnQiLCJjb29raWUiLCJtYXRjaCIsInRva2VuIiwiY29uc29sZSIsIndhcm4iLCJFdmVudCIsInVybE9iaiIsIlVSTCIsInJlcGxhY2UiLCJiYXNlVXJsIiwicHJvdG9jb2wiLCJob3N0IiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZGlzY29ubmVjdCIsImF1dGgiLCJxdWVyeSIsInRyYW5zcG9ydHMiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkF0dGVtcHRzIiwiYXV0b0Nvbm5lY3QiLCJvbiIsInJlYXNvbiIsInNldFRpbWVvdXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJkYXRhIiwidHlwZSIsInBheWxvYWQiLCJvbkFueSIsImV2ZW50TmFtZSIsImFyZ3MiLCJsZW5ndGgiLCJjbGVhclRpbWVvdXQiLCJjb25uZWN0aW5nIiwic2VuZCIsImVtaXQiLCJXU19FVkVOVFMiLCJBTEVSVF9DUkVBVEVEIiwiQUxFUlRfVVBEQVRFRCIsIkFMRVJUX1JFU09MVkVEIiwiTUVUUklDU19VUERBVEUiLCJMT0dfRU5UUlkiLCJBTk9NQUxZX0RFVEVDVEVEIiwiUFJFRElDVElPTl9VUERBVEUiLCJBQ1RJT05fU1RBUlRFRCIsIkFDVElPTl9DT01QTEVURUQiLCJBQ1RJT05fRkFJTEVEIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/websocket.ts\n"));

/***/ })

});